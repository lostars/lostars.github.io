<!DOCTYPE html><html><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><link rel="shortcut icon" href="/images/blog/favicon.svg"><meta name="keywords" content=""><meta name="description" content=""><link rel="stylesheet" href="/styles/main.css"><link rel="stylesheet" href="/styles/post.css"><title>EFFECTIVE JAVA 3RD EDITION — 第三章 对象基本方法 - Daydream</title><meta name="generator" content="Hexo 7.3.0"></head><body><header><nav><ul><li><a href="/">Home</a></li><li><a href="/posts/"><span>Posts</span></a></li><li><a href="/categories/"><span>Categories</span></a></li><li><a href="/about"><span>About</span></a></li></ul></nav></header><main><header><h1>EFFECTIVE JAVA 3RD EDITION — 第三章 对象基本方法</h1><div><time>2018-01-11</time><div class="post-categories"><span class="category-tree"><span class="category-separator">/</span> <a href="/categories/dev/">dev</a></span></div><div class="post-tags"><span class="tag"><span class="category-separator">#</span> <a href="/tags/effective-java-3rd/">effective-java-3rd</a></span></div></div></header><h2 id="Item-10-Obey-the-general-contract-when-overriding-equals"><a href="#Item-10-Obey-the-general-contract-when-overriding-equals" class="headerlink" title="Item 10 : Obey the general contract when overriding equals"></a>Item 10 : Obey the general contract when overriding equals</h2><p><strong>遵守重写 equals方法基本规则</strong></p><p>以下几种情况最好不要重写 equals 方法：</p><ul><li>对象的每个实例都肯定不一样，比如 Thread</li><li>没有必要（不关心）是否逻辑上是否相等，比如 Pattern</li><li>父类已经重写了 equals 方法</li><li>类是私有或者包内私有，并且你确定不会调用 equals 方法，为了规避风险你可以重写方法然后抛出异常<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">equals</span><span class="hljs-params">(Object o)</span> &#123;<br>       <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AssertionError</span>(); <span class="hljs-comment">// Method is never called</span><br>   &#125;<br></code></pre></td></tr></table></figure>当有一个逻辑上相等的概念的时候才会重写 equals 方法，而不是单纯的去判断是否同一个引用，<br>但对于像单例，枚举这种有实例控制（instance control Item 1）的类，逻辑上相等和实际引用是一回事了。</li></ul><p>重写 equals 方法需要注意下面几点（均来自 Object 的 equals 方法说明） x,y,z均不为null：</p><ol><li>自反性，x.equals(x) 必须返回true</li><li>对称性，x.equals(y) 返回 true 当且仅当 y.equals(x)</li><li>传递性，x.equals(y), y.equals(z), 返回 true，那么 x.equals(z) 返回 true</li><li>确定性（一致性），x.equals(y) 要么一直返回true 要么一直返回false</li><li>与空对象比较肯定返回 false，x.equals(null)&#x3D;false</li></ol><p>很难扩展一个已经实例化的类，添加一个属性的同时又要保证上面的约束，除非你想放弃面向对象抽象的好处，但是可以这样实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">equals</span><span class="hljs-params">(Object o)</span> &#123;<br>    <span class="hljs-keyword">if</span> (o == <span class="hljs-literal">null</span> || o.getClass() != getClass())<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-type">Point</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> (Point) o;<br>    <span class="hljs-keyword">return</span> p.x == x &amp;&amp; p.y == y;<br>&#125;<br></code></pre></td></tr></table></figure><p>但是如果有子类的话，这个方法就无法得要预期结果，并且也违反了上面的一致性。<br>Liskov substitution principle 提到一个类型所有重要属性都需要为其子类提供稳定、一致的方法，显然上面的实现没有做到。</p><p>一个好的解决方法：Item 18 : favor composition over inheritance 优先构成而不是继承，比如上面可以不用继承父类而是提供一个私有的父类属性：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ColorPoint</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Point point;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Color color;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ColorPoint</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y, Color color)</span> &#123;<br>        point = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Point</span>(x, y);<br>        <span class="hljs-built_in">this</span>.color = Objects.requireNonNull(color);<br>    &#125;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">    * Returns the point-view of this color point.</span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-keyword">public</span> Point <span class="hljs-title function_">asPoint</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> point;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">equals</span><span class="hljs-params">(Object o)</span> &#123;<br>        <span class="hljs-keyword">if</span> (!(o <span class="hljs-keyword">instanceof</span> ColorPoint))<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-type">ColorPoint</span> <span class="hljs-variable">cp</span> <span class="hljs-operator">=</span> (ColorPoint) o;<br>        <span class="hljs-keyword">return</span> cp.point.equals(point) &amp;&amp; cp.color.equals(color);<br>    &#125;<br>    ... <span class="hljs-comment">// Remainder omitted</span><br>&#125;<br></code></pre></td></tr></table></figure><p>Java中 Timestamp 却在继承了 Date 之后扩展了一个 nanoseconds 属性，但是文档中说明了不要混用 Date 和 Timestamp。<br>继承抽象类可以放心的扩展子类属性而不用担心 equals 方法约束，因为抽象类无法实例化。</p><p>不管一个类是否可变都不要写一个依赖不可靠资源的 equals 方法。<br>比如 java.net.URL 的 equals 方法，就是依赖 ip 来判断是否相等，但是 ip 每次获取到可能是不一样的，所以 equals 方法最好只对内存驻留对象提供，而不是依赖不可靠的资源。</p><p>很多 equals 方法都做了 null 处理，比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">equals</span><span class="hljs-params">(Object o)</span> &#123;<br>    <span class="hljs-keyword">if</span> (o == <span class="hljs-literal">null</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><p>但事实上只需要判断类型即可，因为 null instanceof Type 是肯定返回 false 的。</p><p>一个高质量的 equals 方法需要做到：</p><ol><li>使用 &#x3D;&#x3D; 判断对象引用</li><li>使用 instanceof 判断类型</li><li>强制类型转换，instanceof 使用时已经转换过了，所以肯定是对应类型</li><li>对类的重要部分作判断，全部通过返回 true，否则返回 false</li></ol><ul><li>基本数据类型除了 float 和 double 使用 &#x3D;&#x3D; 比较，引用类型使用 equals 比较</li><li>float 使用静态方法：Float.compare(float, float)，double 使用静态方法：Double.compare(double, double)<br>Float 和 Double 的 equals 方法都存在自动拆装箱</li><li>数组使用 Arrays.equals</li></ul><p>equals 方法的性能取决于比较的内容，为了性能优先比较最可能不同的或者是性能消耗最小的，或者同时兼顾两者。</p><p>不要去比较对象的逻辑状态，比如同步锁。</p><p>没有必要比较派生出来的属性，但是比较了有可能会有性能提升，比如有一个面积属性，你就不需要再去比较长和宽了。</p><p>尽量避免手动重写 equals 方法，使用IDE自动生成或者<a target="_blank" rel="noopener" href="https://github.com/google/auto">AutoValue framework</a>等类似框架。</p><p>尽量不要重写 equals 方法，除非必须，确保方法返回的是你想要的结果。</p><h2 id="Item-11-Always-override-hashCode-when-you-override-equals"><a href="#Item-11-Always-override-hashCode-when-you-override-equals" class="headerlink" title="Item 11 : Always override hashCode when you override equals"></a>Item 11 : Always override hashCode when you override equals</h2><p><strong>重写 equals方法时重写 hashCode方法</strong></p><p>重写 hashCode 必须遵循：</p><ul><li>同一个应用中反复执行 hashCode 方法必须返回相同的值</li><li>如果两个对象通过 equals 方法判断是相等的，那么 hashCode 应该返回同样的值</li><li>如果两个对象通过 equals 方法判断不相等，hashCode 不一定返回不同的值<br>equlas 方法不相等的两个对象返回不同的 hashCode 有助于提升哈希表的性能</li></ul><p>重写 hashCode 失败往往违反的是上面第二条。重写一个规范的 hashCode 方法按照下面的流程：</p><ol><li>义一个 int 类型的局部变量 result ，使用 2.a初始化这个值</li><li>每一个在 equals 方法中用到的部分（变量）f 执行下面操作<br>a. 为每一个f计算一个 int 值 c:<br>如果这个属性是基本类型，那么使用对应包装类型的 hashCode 方法 Type.hashCode(f)；<br>如果这个属性是引用类型，如果是 null 那么用 0（或者其他常量），不是 null 直接使用引用类的 hashCode 方法；<br>如果是数组，如果数组有元素用于 equals 方法，把每个元素当做单独的递归调用2.a, 2.b，如果数组没有一个元素在 equals 方法中使用，那么用0或者其他常量代替；<br>b. 使用下面的方式来计算 hashCode : result &#x3D; 31 * result + c<br>为什么用 31 ，31 是个素数，如果是偶数的话容易倍增溢出导致信息丢失，31 * i &#x3D;&#x3D; (i &lt;&lt; 5) – i 可以用位移和一个减法来代替，可以提升性能。</li><li>返回 result</li></ol><p>比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hashCode</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> Short.hashCode(areaCode);<br>    result = <span class="hljs-number">31</span> * result + Short.hashCode(prefix);<br>    result = <span class="hljs-number">31</span> * result + Short.hashCode(lineNum);<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><p>千万避免使用没有用于 equals 方法的变量，步骤2.b 很依赖你使用变量的顺序。</p><p>Objects 类提供了一个快速获取 hash 值的静态方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hashCode</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> Objects.hash(lineNum, prefix, areaCode);<br>&#125;<br></code></pre></td></tr></table></figure><p>性能要求苛刻的场景不推荐使用，内部其实使用的数组来处理，会有自动拆装箱带来的性能损耗，该方法内部调用其实是 Arrays.hashCode ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hashCode</span><span class="hljs-params">(Object a[])</span> &#123;<br>        <span class="hljs-keyword">if</span> (a == <span class="hljs-literal">null</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (Object element : a)<br>            result = <span class="hljs-number">31</span> * result + (element == <span class="hljs-literal">null</span> ? <span class="hljs-number">0</span> : element.hashCode());<br>        <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><p>其实也是符合上面的重写流程。</p><p>如果一个类是不变（单例等等），计算 hashCode 比较消耗性能，考虑缓存 hashCode，比如下面的实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> hashCode; <span class="hljs-comment">// Automatically initialized to 0</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hashCode</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> hashCode;<br>    <span class="hljs-keyword">if</span> (result == <span class="hljs-number">0</span>) &#123;<br>        result = Short.hashCode(areaCode);<br>        result = <span class="hljs-number">31</span> * result + Short.hashCode(prefix);<br>        result = <span class="hljs-number">31</span> * result + Short.hashCode(lineNum);<br>        hashCode = result;<br>    &#125;<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>不要尝试排除部分 equals 方法中使用的属性来提升 hashCode 方法性能</li><li>不要给一个 hashCode 方法提供详细的规范（或者文档），使用者就没有理由依赖它，你可以灵活的进行改动（换言之就是不要轻易留坑，防止背锅）</li></ul><h2 id="Item-12-Always-override-toString"><a href="#Item-12-Always-override-toString" class="headerlink" title="Item 12 :  Always override toString"></a>Item 12 : Always override toString</h2><p><strong>总是重写 toString方法</strong></p><p>这个比较容易理解也很简单。重写一个好的 toString 方法有助于是你的类看起来更舒服，让系统使用更简单和易于调试。toString 方法应该返回所有对象值得关注的内容。</p><p>定义 toString 方法返回格式，特别的对于以值为主的类：</p><ul><li>好处在于可以作为一个标准，便于阅读，通常还需要提供一个工厂方法或者构造器来转换 string 和 对象</li><li>缺点在于如果你的类被很多人使用，调用者用来持久化数据，一旦改动 toString 方法，代价将是非常大的</li></ul><p>所以需要在文档里写明你的意图，是确定好了返回格式，还是该方法返回数据格式可能在将来会有改动（程序员要时刻注意是否留坑）。</p><p>不管是否确定返回格式都需要返回数据包含重要信息或者关注的信息，总的来说重写 toString 方法，除非父类已经重写，易于使用和调试，返回数据应该清晰，包含类的描述信息，易于阅读。</p><h2 id="Item-13-Override-clone-judiciously"><a href="#Item-13-Override-clone-judiciously" class="headerlink" title="Item 13 : Override clone judiciously"></a>Item 13 : Override clone judiciously</h2><p><strong>正确的重写 clone方法</strong></p><p>clone方法需要遵循：</p><ol><li>x.clone() !&#x3D; x 返回 true</li><li>x.clone().getClass() &#x3D;&#x3D; x.getClass() 或者 x.clone().equals(x) 返回 true ，这个不是必须的</li></ol><p>不要给不变的类提供 clone 方法，防止不必要的类复制。</p><p>当类有对象引用时让 clone 方法提供像构造器一样的功能，同时保证对原对象没有影响，在复制过程中保持不变，比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> Stack <span class="hljs-title function_">clone</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-type">Stack</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> (Stack) <span class="hljs-built_in">super</span>.clone();<br>        result.elements = elements.clone();<br>        <span class="hljs-keyword">return</span> result;<br>    &#125; <span class="hljs-keyword">catch</span> (CloneNotSupportedException e) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AssertionError</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>普通容易改变的类如果有 final 属性是不适合使用 clone 方法，除非该属性是在他自己和副本之间安全共享的。</p><p>为了让一个类可复制，有必要移除一些属性的 final 修饰。</p><p>上面例子虽然简洁的实现了 clone ，但是与 Cloneable 设计想法相悖的，因为上面例子只是一味的一个一个属性的复制来创建一个副本。</p><p>和构造器一样，clone 方法在执行过程中不能调用可以被重写的方法，如果调用了那么这个方法有机会修改在 clone 过程中的状态。</p><p>Object 的 clone 方法抛出了 CloneNotSupportedException 异常，但是重写的 clone 方法不需要，公共 clone 方法应该忽略这个异常方便使用（item 71）。</p><p>一个可继承的类都不应该实现 Cloneable 接口，或者你可以在 clone 方法中抛出异常，比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> Object <span class="hljs-title function_">clone</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> CloneNotSupportedException<br>&#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CloneNotSupportedException</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>还有一点值得注意，如果一个类是线程安全同时又实现了 Cloneable 接口，clone 方法应该被正确的加上同步锁，<br>Object 的 clone 方法不是同步的，虽然是正确的但也需要你实现一个同步的 clone 方法。</p><p>总的来说实现了 Cloneable 接口的类都都应该重写一个公共的（idea自动生成是 protected）的 clone 方法，返回自身类型，而不是 Object；<br>方法应该首先调用 super.clone() 方法，然后覆盖一些对象引用和可变属性，而不是仅仅将拷贝对象属性引用到原对象的属性，如果对象结构比较深的话，<br>可以递归调用相应对象的 clone 方法但不是最好的解决方案。</p><p>一个更好的对象复制的实现是提供一个复制构造方法或者工厂方法，比如下面的实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">Yum</span><span class="hljs-params">(Yum yum)</span> &#123; ... &#125;;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Yum <span class="hljs-title function_">newInstance</span><span class="hljs-params">(Yum yum)</span> &#123; ... &#125;;<br></code></pre></td></tr></table></figure><p>这样实现好处：</p><ul><li>不依赖一个有风险的对象创建机制</li><li>没有强制要求遵守某些规范</li><li>与 final 修饰符不冲突，不影响其使用</li><li>不会抛出检查异常</li><li>没有强制类型转换</li><li>返回类型可选，可以是子类，或者实现类</li></ul><p>由于 Cloneable 的局限与不足，新的接口或者扩展类最好不要实现 Cloneable，但是数组最好的复制方式却是 clone 方法。</p><h2 id="Item-14-Consider-implementing-Comparable"><a href="#Item-14-Consider-implementing-Comparable" class="headerlink" title="Item 14 : Consider implementing Comparable"></a>Item 14 : Consider implementing Comparable</h2><p><strong>考虑实现 Comparable接口</strong></p><p>不像本章到的其他方法定义在 Object ，compareTo 方法是单独定义在 Comparable 接口中的。</p><p>类似于 equals 方法，不过 compareTo 方法除了作简单相等比较之外还要求参数顺序，并且该方法是通用的。</p><p>如果类需要一些排序功能或者排序敏感那么可以实现 Comparable 接口，同时遵循下面规则：</p><ul><li>必须保证 sgn(x.compareTo(y)) &#x3D;&#x3D; -sgn(y. compareTo(x)) 其实有点类似 equals 方法的反身性</li><li>传递性，(x. compareTo(y) &gt; 0 &amp;&amp; y.compareTo(z) &gt; 0) 那么 x.compareTo(z) &gt; 0</li><li>如果 x.compareTo(y) &#x3D;&#x3D; 0 那么 sgn(x.compareTo(z)) &#x3D;&#x3D; sgn(y.compareTo(z)) 对所有的 z 都成立</li><li>(x.compareTo(y) &#x3D;&#x3D; 0) &#x3D;&#x3D; (x.equals(y)) 建议但不是必须的</li></ul><p>不像 equals 方法是针对所有对象的，compareTo 方法只是针对同类对象的，如果不是同类对象调用会抛出 ClassCastException，<br>和违反 equals 方法基本原则一样，违反 compareTo 方法基本原则也会影响依赖比较的类，比如排序和搜索等等功能。</p><p>如果你想给一个实现了 Comparable 接口的类扩展属性，或者是继承，写一个不相关的类添加一个类引用即可，然后提供一个查看的方法来返回引用实例。</p><p>上面第四点虽然不是强制要求，但是如果 equals 和 compareTo方法不能保持一致的话，compareTo 方法能够正常执行，<br>但是包含这个类的集合排序结果可能就不是集合接口本身定义的排序顺序了，因为接口定义是就 equals 方法而言的，而集合排序功能是针对 compareTo 方法的，所以这点非常值得注意。</p><p>比如 BigDecimal 这个类就是 equals 和 compareTo 方法不是一致的，如果我往一个 HashSet 里放入 new BigDecimal(“1.0”) 和 new BigDecimal(“1.00”)，<br>里面会有两个元素，因为 BigDecimal equals 判断是不等的，<br>但是如果你用 TreeSet 就只有一个元素，因为 compareTo 比较是相等的。</p><p>与重写 equals 方法不同：</p><ul><li>由于比较都是同类型的，所以不需要进行类型检查</li><li>比较方法是比较顺序而不是是否相等或者是值</li></ul><p>该书旧版本提到比较除了 float 和 double 的其他基本数据类型使用大于小于来比较，而 float 和 double 则使用 Double.compare 对应包装类的 compare 方法，<br>Java7以后所有的包装类都有该方法，使用大于小于和包装类 compare 方法都是不推荐的，容易出错。</p><p>具体实现类似重写 hashCode 的流程：<br>有多个重要属性的时候，比较的先后顺序十分严格，按照重要性能先后比较，如果相等就返回，否则比较下一个，直到找到不等（有序）的属性返回，比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compareTo</span><span class="hljs-params">(PhoneNumber pn)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> Short.compare(areaCode, pn.areaCode);<br>    <span class="hljs-keyword">if</span> (result == <span class="hljs-number">0</span>) &#123;<br>        result = Short.compare(prefix, pn.prefix);<br>        <span class="hljs-keyword">if</span> (result == <span class="hljs-number">0</span>)<br>            result = Short.compare(lineNum, pn.lineNum);<br>    &#125;<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><p>java 8中 Comparator 提供了一个比较器的集合，可以让比较更加流畅，这些比较器可以用于实现 Comparable 接口，可能会有性能的略微下降，例如下面的实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Comparator</span> <span class="hljs-variable">COMPARATOR</span> <span class="hljs-operator">=</span><br>    comparingInt((PhoneNumber pn) -&amp;gt; pn.areaCode)<br>    .thenComparingInt(pn -&amp;gt; pn.prefix)<br>    .thenComparingInt(pn -&amp;gt; pn.lineNum);<br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compareTo</span><span class="hljs-params">(PhoneNumber pn)</span> &#123;<br>    <span class="hljs-keyword">return</span> COMPARATOR.compare(<span class="hljs-built_in">this</span>, pn);<br>&#125;<br></code></pre></td></tr></table></figure><p>对应的也有 comparingLong 等方法，覆盖了全部的java基本类型，short可以用 comparingInt, double 可以使用 comparingLong。</p><p>同时也提供了引用对象的比较器，使用 comparing 方法，提供了两种重载，一个传入一个 key extractor 使用 key 的自然顺序，一个传入一个 key extractor 和 一个比较器。</p><p>thenComparing 方法提供了三种重载，具体可查看 Comparator 文档。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> Comparator&lt;Object&gt; hashCodeOrder = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Comparator</span>&lt;&gt;() &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(Object o1, Object o2)</span> &#123;<br>        <span class="hljs-keyword">return</span> o1.hashCode() - o2.hashCode();<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>避免上面这种实现，违反了第二条传递性，而使用:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> Comparator&lt;Object&gt; hashCodeOrder = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Comparator</span>&lt;&gt;() &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(Object o1, Object o2)</span> &#123;<br>        <span class="hljs-keyword">return</span> Integer.compare(o1.hashCode(), o2.hashCode());<br>    &#125;<br>&#125;;<br>````<br>或者:<br>```java<br><span class="hljs-keyword">static</span> Comparator&lt;Object&gt; hashCodeOrder = Comparator.comparingInt(o -&gt; o.hashCode());<br></code></pre></td></tr></table></figure><p>总的来说对排序敏感的类可以实现 Comparable接口来有助于排序，搜索和比较，避免使用大于小于，而应该用包装类提供的 compare 方法，或者是 Comparator 中提供的比较。</p><blockquote class="copyright"><p>本站所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">BY-NC-SA 4.0</a> 许可协议。转载请注明出处！</p></blockquote></main><nav class="pagination"><span class="prev"><a href="/posts/311">EFFECTIVE JAVA 3RD EDITION — 第四章 类与接口（1） </a></span><span class="next"><a href="/posts/303">EFFECTIVE JAVA 3RD EDITION — 第二章 创建和销毁对象</a></span></nav><script src="/js/main.js"></script><footer><p class="socials"><a href="https://github.com/lostars" target="_blank"><svg class="fontawesome-icon"><use href="/icons/fontawesome.svg#github"></use></svg> </a><a href="https://open.spotify.com/user/boyizmen" target="_blank"><svg class="fontawesome-icon"><use href="/icons/fontawesome.svg#spotify"></use></svg> </a><a href="https://space.bilibili.com/20516992" target="_blank"><svg class="fontawesome-icon"><use href="/icons/fontawesome.svg#bilibili"></use></svg> </a><input type="hidden" id="emailUser" value="bW9tbw=="> <input type="hidden" id="emailDomain" value="bWluZWkubWU="> <a id="emailLink" href="#" target="_blank"><svg class="fontawesome-icon"><use href="/icons/fontawesome.svg#email"></use></svg></a></p><p>Build with ❤ I abandon here my love</p><p>Copyright &copy; 2025 boyizmen</p></footer></body></html>