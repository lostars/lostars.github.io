<!DOCTYPE html><html><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><link rel="shortcut icon" href="/images/blog/favicon.svg"><meta name="keywords" content=""><meta name="description" content=""><link rel="stylesheet" href="/styles/main.css"><link rel="stylesheet" href="/styles/post.css"><title>EFFECTIVE JAVA 3RD EDITION — 第十章 异常 - Daydream</title><meta name="generator" content="Hexo 7.3.0"></head><body><header><nav><ul><li><a href="/">Home</a></li><li><a href="/posts/"><span>Posts</span></a></li><li><a href="/categories/"><span>Categories</span></a></li><li><a href="/about"><span>About</span></a></li></ul></nav></header><main><header><h1>EFFECTIVE JAVA 3RD EDITION — 第十章 异常</h1><div><time>2019-02-28</time><div class="post-categories"><span class="category-tree"><span class="category-separator">/</span> <a href="/categories/dev/">dev</a></span></div><div class="post-tags"><span class="tag"><span class="category-separator">#</span> <a href="/tags/effective-java-3rd/">effective-java-3rd</a></span></div></div></header><h2 id="Item-69-Use-exceptions-only-for-exceptional-conditions"><a href="#Item-69-Use-exceptions-only-for-exceptional-conditions" class="headerlink" title="Item 69 : Use exceptions only for exceptional conditions"></a>Item 69 : Use exceptions only for exceptional conditions</h2><p><strong>只在异常情况下使用异常</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Horrible abuse of exceptions. Don&#x27;t ever do this! </span><br><span class="hljs-keyword">try</span> &#123;    <br>    <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;    <br>    <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)        <br>    range[i++].climb(); <br>&#125; <span class="hljs-keyword">catch</span> (ArrayIndexOutOfBoundsException e) &#123;&#125; <br></code></pre></td></tr></table></figure><p>上面错误的使用了异常，在循环中使用ArrayIndexOutOfBoundsException只是为了保证没有越界发生，这种情况应该是使用增强的for循环来避免</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span> (Mountain m : range)    m.climb(); <br></code></pre></td></tr></table></figure><p>异常只是设计用在一些异常的场景，而不是通过异常来作一些性能提升；同时把代码放在try-catch代码块中会影响jvm的某些优化；通常数组的循环不需要额外的冗余检查，jvm会自动优化。</p><p>异常检查的场景通常会影响性能，并且也不一定能够保证代码正常执行，如果在循环中调用了一个方法抛出了数组越界，但是该方法在try-catch块中，这对定位bug增加了不少难度，但是如果没有这样程序则会直接抛出异常并终止运行。</p><p>总的来说就是异常只用在需要异常检查的场景，而不是用于普通的流程控制。同时在API中，好的API不会强迫用户在普通流程控制中使用异常。</p><p>一个状态依赖的类，如果在不可预测的条件下执行则需要提供一个状态检查的方法来判断是否可执行，比如迭代器的hasNext方法或者也可以返回一个不同的值，比如null来表示无法进行操作。</p><p>如果没有外部同步的情况下访问对象或者状态会受到外部影响则应该使用后者，除此之外应使用状态检查方法，状态检测方法拥有更好的可读性，并且能更容易检查到错误使用：如果没有调用状态检测方法则会抛出异常但后者如果你忘了对返回值进行检查的话就可能引起严重的错误。</p><h2 id="Item-70-Use-checked-exceptions-for-recoverable-conditions-and-runtime-exceptions-for-programming-errors"><a href="#Item-70-Use-checked-exceptions-for-recoverable-conditions-and-runtime-exceptions-for-programming-errors" class="headerlink" title="Item 70 : Use checked exceptions for recoverable conditions and runtime exceptions for programming errors"></a>Item 70 : Use checked exceptions for recoverable conditions and runtime exceptions for programming errors</h2><p><strong>在需要恢复的场景使用检查异常，程序错误使用运行时异常</strong></p><p>Java提供了3种可抛出异常：检查异常、运行时异常、错误<br>在可以合理预期调用者恢复的情况下使用检查异常，抛出检查异常将强迫调用者去处理该异常或者继续向外抛出。未检查异常包括运行时异常和错误，这两种异常通常都不应该被捕获，抛出未检查异常表明基本不可能被恢复并且如果继续执行将会更糟。</p><p>使用运行时异常来表明程序错误，大多数的运行时异常都表示违反了前提条件，比如数组的下标都是非负数。而错误则只是JVM用来表明资源不足，持续性的失败或者其他任何导致程序继续执行的情况。通常情况下都不要继承任何Error类，而你的未检查异常则应该是RuntimeException的子类（直接或间接）。</p><p>总的来说检查异常是用于可恢复的场景，而未检查异常则用于程序错误，不知道用什么的时候使用后者。同时不要定义任何既不是检查异常也不是运行时异常的Throwables。</p><h2 id="Item-71-Avoid-unnecessary-use-of-checked-exceptions"><a href="#Item-71-Avoid-unnecessary-use-of-checked-exceptions" class="headerlink" title="Item 71: Avoid unnecessary use of checked exceptions"></a>Item 71: Avoid unnecessary use of checked exceptions</h2><p><strong>避免使用不必要的检查异常</strong></p><p>API中过度的使用检查异常会增加使用API的负担，调用者需要反复的编写try-catch代码块来处理异常，这在Java8中更加的明显，因为在流中不能使用抛出检查异常的方法。</p><p>这个时候可以返回不同的值以便在流中可以使用，或者把检查异常改为未检查异常。</p><p>总的来说适当的使用检查异常可以增加程序的稳定性，但是滥用则会导致使用十分麻烦，如果调用者不能从失败中恢复，则抛出未检查异常更为合适，只有在失败失败情况下信息不足时才抛出检查异常。</p><h2 id="Item-72-Favor-the-use-of-standard-exceptions"><a href="#Item-72-Favor-the-use-of-standard-exceptions" class="headerlink" title="Item 72: Favor the use of standard exceptions"></a>Item 72: Favor the use of standard exceptions</h2><p><strong>使用标准异常</strong></p><p>复用标准异常有几个好处：</p><ul><li>会使你的API更加的容易上手，因为使用的标准异常都熟悉；</li><li>使用API的代码更容易阅读，因为没有不熟悉的异常类；</li><li>更少的异常类意味着更少的内存占用和类加载时间；<br>可以说每个错误的方法调用都可以归结于非法的参数或状态，其他例外异常都用于某些类型的非法参数和状态。比如传入一个null值，调用则会抛出NullPointerException 异常而不是IllegalArgumentException。</li></ul><p>IllegalArgumentException用于调用者的参数不正确；<br>IllegalStateException表示接收的对象状态不合法，比如调用者想要在对象初始化前使用该对象；<br>ConcurrentModificationException用于如果一个设计在单线程场景的对象检测到被修改了抛出该异常，但是该异常充其量只是一个提示，并不能可靠的检测并发修改。</p><p>不要直接使用Exception RuntimeException Throwable Error，把他们当成抽象类。</p><h2 id="Item-73-Throw-exceptions-appropriate-to-the-abstraction"><a href="#Item-73-Throw-exceptions-appropriate-to-the-abstraction" class="headerlink" title="Item 73: Throw exceptions appropriate to the abstraction"></a>Item 73: Throw exceptions appropriate to the abstraction</h2><p><strong>抛出适合抽象的异常</strong></p><p>高级封装的API应该catch掉同层级的低等级异常，同时用高级封装来抛出异常，这通常叫做异常转换，比如AbstractSequentialList</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Returns the element at the specified position in this list.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> </span><br><span class="hljs-comment">This implementation first gets a list iterator pointing to the</span><br><span class="hljs-comment"> * indexed element (with &lt;tt&gt;listIterator(index)&lt;/tt&gt;).  Then, it gets</span><br><span class="hljs-comment"> * the element using &lt;tt&gt;ListIterator.next&lt;/tt&gt; and returns it.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@throws</span> IndexOutOfBoundsException &#123;<span class="hljs-doctag">@inheritDoc</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> E <span class="hljs-title function_">get</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">return</span> listIterator(index).next();<br>    &#125; <span class="hljs-keyword">catch</span> (NoSuchElementException exc) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IndexOutOfBoundsException</span>(<span class="hljs-string">&quot;Index: &quot;</span>+index);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>异常链：低级异常通过高级异常的封装抛出，同时高级封装包含了低级封装的异常信息有助于debug。</p><p>虽然异常转换优于低层异常的抛出，但是也不能过度使用，最好就是处理掉低层的异常。如果无法避免低层异常的抛出，则高层最好静默处理掉这些异常，让上层调用者没有感知，这样有可能让一些日志组件无法记录异常信息。</p><p>总的来说避免底层的异常时不太可行的，通过异常转换来处理低层的异常来隔离用户，或者使用异常链来抛出合适的异常。</p><h2 id="Item-74-Document-all-exceptions-thrown-by-each-method"><a href="#Item-74-Document-all-exceptions-thrown-by-each-method" class="headerlink" title="Item 74: Document all exceptions thrown by each method"></a>Item 74: Document all exceptions thrown by each method</h2><p><strong>用注释说明每个方法抛出的异常</strong></p><p>异常描述是一个方法文档的重要部分，所以仔细的说明方法抛出的异常时非常重要的。始终单独声明检查异常，并且用@throws注解来描述清楚每一个异常条件。</p><p>不要简单的注解方法抛出了一个异常父类，比如 throws Exception或者throws Throwable，这样的声明极大的妨碍了该方法的使用，同时会让其他异常显得更加模糊。尽管java本身不要求程序员声明未检查异常，但是仔细的用文档描述清楚未检查异常能够帮助用户避免抛出未检查异常。</p><p>如果一个类的很多方法抛出同一个异常，那么异常的文档注释最好写在类的注释上，而不是每一个方法上。总的来说就是注释清楚每一个抛出的异常。</p><h2 id="Item-75-Include-failure-capture-information-in-detail-messages"><a href="#Item-75-Include-failure-capture-information-in-detail-messages" class="headerlink" title="Item 75: Include failure-capture information in detail messages"></a>Item 75: Include failure-capture information in detail messages</h2><p><strong>将失败捕获信息包含在异常中</strong></p><p>一个程序的异常堆栈信息是分析错误的很重要东西，如果堆栈信息没有输出重要的异常信息同时这个错误又很难浮现那么将很难解决问题。为了捕获一个错误，异常的详细信息应该包含对异常有帮助的所有参数和属性。但为了安全，不要在异常详细信息中包含密码，密钥类似的信息。</p><p>总的来说在检查异常中提供一个构造方法来提供错误详细信息。</p><h2 id="Item-76-Strive-for-failure-atomicity"><a href="#Item-76-Strive-for-failure-atomicity" class="headerlink" title="Item 76: Strive for failure atomicity"></a>Item 76: Strive for failure atomicity</h2><p><strong>保证失败的原子性</strong></p><p>一般来说，一个方法失败了应该让对象保持方法执行前的状态，要实现这个可以采用下面的方式：</p><ul><li>可以让对象不可变，final；</li><li>在方法执行前对参数的有效性进行检查；</li><li>对所有的计算进行排序，让所有可能失败的操作都在修改对象状态之前进行；</li><li>用一个拷贝的副本进行计算，当计算完成再进行替换操作；</li><li>编写恢复代码在失败的时候对状态进行恢复；<br>总的来说任何异常都应该在抛出后保证对象的原始状态，但是很多的API都没有保证一这点。</li></ul><h2 id="Item-77-Don’t-ignore-exceptions"><a href="#Item-77-Don’t-ignore-exceptions" class="headerlink" title="Item 77: Don’t ignore exceptions"></a>Item 77: Don’t ignore exceptions</h2><p><strong>不要忽略任何异常</strong></p><p>一个空的catch块违背了异常设计的初衷，但是也有场景需要我们忽略一些异常，比如在关闭FileInputStream时，并没有修改文件状态所以也不需要任何恢复操作。同时如果选择忽略异常，那么就要在catch块中注释说明，并且参数应该命名为ignored。</p><p>总的来说处理异常能够完全避免失败，如果让异常向外抛出能导致快速失败，保留详细的失败信息来进行调试。</p><hr><p>这一章主要介绍了异常的使用规范，同时不要忽略任何异常，也不要尝试去catch掉所有异常而不去处理他们。</p><blockquote class="copyright"><p>本站所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">BY-NC-SA 4.0</a> 许可协议。转载请注明出处！</p></blockquote></main><nav class="pagination"><span class="prev"><a href="/posts/538">EFFECTIVE JAVA 3RD EDITION — 第十一章 并发编程 </a></span><span class="next"><a href="/posts/502">EFFECTIVE JAVA 3RD EDITION — 第九章 日常编程</a></span></nav><script src="/js/main.js"></script><footer><p class="socials"><a href="https://github.com/lostars" target="_blank"><svg class="fontawesome-icon"><use href="/icons/fontawesome.svg#github"></use></svg> </a><a href="https://open.spotify.com/user/boyizmen" target="_blank"><svg class="fontawesome-icon"><use href="/icons/fontawesome.svg#spotify"></use></svg> </a><a href="https://space.bilibili.com/20516992" target="_blank"><svg class="fontawesome-icon"><use href="/icons/fontawesome.svg#bilibili"></use></svg> </a><input type="hidden" id="emailUser" value="bW9tbw=="> <input type="hidden" id="emailDomain" value="bWluZWkubWU="> <a id="emailLink" href="#" target="_blank"><svg class="fontawesome-icon"><use href="/icons/fontawesome.svg#email"></use></svg></a></p><p>Build with ❤ I abandon here my love</p><p>Copyright &copy; 2025 boyizmen</p></footer></body></html>