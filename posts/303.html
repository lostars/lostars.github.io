<!DOCTYPE html><html><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><link rel="shortcut icon" href="/images/blog/favicon.svg"><meta name="keywords" content=""><meta name="description" content=""><link rel="stylesheet" href="/styles/main.css"><link rel="stylesheet" href="/styles/post.css"><title>EFFECTIVE JAVA 3RD EDITION — 第二章 创建和销毁对象 - Daydream</title><meta name="generator" content="Hexo 7.3.0"></head><body><header><nav><ul><li><a href="/">Home</a></li><li><a href="/posts/"><span>Posts</span></a></li><li><a href="/categories/"><span>Categories</span></a></li><li><a href="/about"><span>About</span></a></li></ul></nav></header><main><header><h1>EFFECTIVE JAVA 3RD EDITION — 第二章 创建和销毁对象</h1><div><time>2018-01-10</time><div class="post-categories"><span class="category-tree"><span class="category-separator">/</span> <a href="/categories/dev/">dev</a></span></div><div class="post-tags"><span class="tag"><span class="category-separator">#</span> <a href="/tags/effective-java-3rd/">effective-java-3rd</a></span></div></div></header><h2 id="Item-1-using-static-factory-method-instead-of-constructor"><a href="#Item-1-using-static-factory-method-instead-of-constructor" class="headerlink" title="Item 1 : using static factory method instead of constructor"></a>Item 1 : using static factory method instead of constructor</h2><p><strong>多使用静态工厂方法而不是构造器</strong></p><p>优势：</p><ul><li>构造器容易造成参数顺序混乱，静态工厂方法名称有很好的表意性，对于类属性较多的情况有着非常明显的优势</li><li>静态工厂方法都不必每次调用都创建新的对象，对于创建开销很大的对象或者同一个对象反复调用来说有性能提升（实现instance-controlled）<br>instance-controlled classes(Flyweight Pattern):<ol><li>保证是一个单例或者不可实例化</li><li>保证不存在两个完全相同的实例</li></ol></li><li>静态工厂方法返回对象灵活，可以是自己或者是子对象</li><li>静态工厂方法可以根据参数返回不同的对象（自身或者是子对象，或者说是不同的实现）</li><li>静态工厂方法返回的对象在方法所在的类写入之前都可以不用存在</li></ul><p>不足：</p><ul><li>只提供静态工厂方法，由于没有公共或者保护的构造器无法被继承，扩展性有限</li><li>开发人员很难注意到静态工厂方法，java文档中构造器的文档比静态工厂方法更显眼（可以忽略）</li></ul><p>常用静态工厂方法命名：</p><ol><li>from 单参数的类型转换</li><li>of 多参数聚合转换</li><li>valueOf from和of更详细的转换</li><li>instance or getInstance 有可能返回相同的实例</li><li>create or newInstance 返回新实例</li><li>getType 同getInstance，如果工厂方法定义在另一个类中</li><li>newType 同上</li><li>type 同上</li></ol><h2 id="Item-2-considering-a-builder-when-faced-with-many-constructor-parameters"><a href="#Item-2-considering-a-builder-when-faced-with-many-constructor-parameters" class="headerlink" title="Item 2 : considering a builder when faced with many constructor parameters"></a>Item 2 : considering a builder when faced with many constructor parameters</h2><p><strong>构造器参数过多时考虑使用builder模式</strong></p><p>builder模式在Java 9中其实使用非常多，比如介绍 <a href="https://minei.me/archives/302.html">Java9 HTTP2新特性</a> 里面HttpClient HttpRequest等等的实例化方式都是builder模式。</p><p>静态工厂方法和构造器在面对大量可选参数时候的扩展性非常不好：</p><ul><li>普通伸缩构造模式在参数多了的情况下调用代码难于编写和阅读<br>想象一下当我new 一个对象需要传入超过5个参数的时候，根本不知道参数先后顺序，还要看文档，是多么痛苦的一件事情。</li><li>get,set方法过于啰嗦，虽然解决了上面的不足，但是在构造对象的过程中对象可能已经被改变，导致线程不安全，这是JavaBeans模式的一个短板<br>当一个类有超过10个属性的时候使用get,set方法简直就是一场灾难。</li></ul><p>比如你可以像下面一样实现builder模式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Human</span> &#123;<br> <br>    <span class="hljs-keyword">private</span> String name;<br> <br>    <span class="hljs-keyword">private</span> Integer id;<br> <br>    <span class="hljs-keyword">private</span> <span class="hljs-type">char</span> sex;<br> <br>    <span class="hljs-keyword">private</span> Date birthday;<br> <br>    <span class="hljs-keyword">private</span> Double height;<br> <br>    <span class="hljs-keyword">private</span> Double weight;<br> <br>    <span class="hljs-keyword">private</span> String motto;<br> <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Builder</span> &#123;<br>        <span class="hljs-keyword">private</span> String name;<br> <br>        <span class="hljs-keyword">private</span> Integer id;<br> <br>        <span class="hljs-keyword">private</span> <span class="hljs-type">char</span> sex;<br> <br>        <span class="hljs-keyword">private</span> Date birthday;<br> <br>        <span class="hljs-keyword">private</span> Double height;<br> <br>        <span class="hljs-keyword">private</span> Double weight;<br> <br>        <span class="hljs-keyword">private</span> String motto;<br> <br>        <span class="hljs-keyword">public</span> Builder <span class="hljs-title function_">name</span><span class="hljs-params">(String name)</span> &#123;<br>            <span class="hljs-built_in">this</span>.name = name;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;<br>        &#125;<br>        <span class="hljs-keyword">public</span> Builder <span class="hljs-title function_">id</span><span class="hljs-params">(Integer id)</span> &#123;<br>            <span class="hljs-built_in">this</span>.id = id;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;<br>        &#125;<br>        <span class="hljs-keyword">public</span> Builder <span class="hljs-title function_">sex</span><span class="hljs-params">(<span class="hljs-type">char</span> sex)</span> &#123;<br>            <span class="hljs-built_in">this</span>.sex = sex;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;<br>        &#125;<br>        <span class="hljs-keyword">public</span> Builder <span class="hljs-title function_">birthday</span><span class="hljs-params">(Date birthday)</span> &#123;<br>            <span class="hljs-built_in">this</span>.birthday = birthday;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;<br>        &#125;<br>        <span class="hljs-keyword">public</span> Builder <span class="hljs-title function_">height</span><span class="hljs-params">(Double height)</span> &#123;<br>            <span class="hljs-built_in">this</span>.height = height;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;<br>        &#125;<br>        <span class="hljs-keyword">public</span> Builder <span class="hljs-title function_">weight</span><span class="hljs-params">(Double weight)</span> &#123;<br>            <span class="hljs-built_in">this</span>.weight = weight;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;<br>        &#125;<br>        <span class="hljs-keyword">public</span> Builder <span class="hljs-title function_">motto</span><span class="hljs-params">(String motto)</span> &#123;<br>            <span class="hljs-built_in">this</span>.motto = motto;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;<br>        &#125;<br>        <span class="hljs-keyword">public</span> Human <span class="hljs-title function_">build</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Human</span>(<span class="hljs-built_in">this</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Human</span><span class="hljs-params">(Builder builder)</span> &#123;<br>        name = builder.name;<br>        id = builder.id;<br>        sex = builder.sex;<br>        birthday = builder.birthday;<br>        height = builder.height;<br>        weight = builder.weight;<br>        motto = builder.motto;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>构造一个Human:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">Human.<span class="hljs-type">Builder</span> <span class="hljs-variable">builder</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Human</span>.Builder();<br>builder.id(<span class="hljs-number">1</span>).name(<span class="hljs-string">&quot;Tom&quot;</span>).birthday(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>()).height(<span class="hljs-number">1.8</span>).weight(<span class="hljs-number">60.0</span>).motto(<span class="hljs-string">&quot;Hello World&quot;</span>);<br>builder.build();<br></code></pre></td></tr></table></figure><p>builder模式的优缺点：</p><ol><li>更加灵活，安全，对参数可以做更多的处理，调用代码可读性好</li><li>在性能要求极端的场景下builder创建所消耗的性能是不被容忍的</li><li>从传统的get,set或者构造方法迁移的时候代码量大（删除旧代码），所以最好一开始就使用builder模式</li></ol><p>使用场景：</p><ul><li>参数过多难以处理，特别是可选参数过多时</li><li>安全</li></ul><h2 id="Item-3-making-singleton-property-private-constructor-or-enum-type"><a href="#Item-3-making-singleton-property-private-constructor-or-enum-type" class="headerlink" title="Item 3 : making singleton property private constructor or enum type"></a>Item 3 : making singleton property private constructor or enum type</h2><p><strong>用枚举代替单例属性或者给它提供一个私有构造方法</strong></p><p>构造一个单例：</p><ul><li>声明一个公共静态final属性，无参构造方法私有<br>优点是api清晰，属性是final的表明其是个单例</li><li>声明一个私有静态final属性，提供一个公共静态获取实例方法返回该属性，同样无参构造方法私有<br>优点是灵活性，返回的实例可以根据需要修改，不用修改api来决定是否是单例；<br>可以写一个通用的单例工厂方法，如果需要的话；<br>可以作为一个 Supplier 比如：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Supplier</span> <span class="hljs-variable">supplier</span> <span class="hljs-operator">=</span> SingletonEnforce::getInstance;<br>supplier.get();<br></code></pre></td></tr></table></figure>但是上面第二种方法有一定的危险，因为私有的构造方法也有可能被调用：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Constructor</span> <span class="hljs-variable">constructor</span> <span class="hljs-operator">=</span> Class.forName(<span class="hljs-string">&quot;me.minei.effective.SingletonEnforce&quot;</span>).getDeclaredConstructor();<br>constructor.setAccessible(<span class="hljs-literal">true</span>);<br>constructor.newInstance();<br></code></pre></td></tr></table></figure><p>这种情况在私有构造方法里判断是否实例化过，已经实例化抛出异常即可。</p><p>声明一个单元素枚举，通常这是最好的方法来实现单例，如果要扩展一个非枚举子类的话就不用这种方式实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> <span class="hljs-title class_">SingletonEnum</span> &#123;<br>    INSTANCE;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用前两种方式实现的单例如果需要序列化的话不光需要实现 Serializable 接口，同时所有实例属性都需要加 transient 关键字和提供一个私有的 readResolve 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> Object <span class="hljs-title function_">readResolve</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> INSTANCE;<br>&#125;<br></code></pre></td></tr></table></figure><p>否则每次反序列化时都会有新的实例创建。</p><h2 id="Item-4-Enforce-noninstantiability-with-a-private-constructor"><a href="#Item-4-Enforce-noninstantiability-with-a-private-constructor" class="headerlink" title="Item 4 : Enforce noninstantiability with a private constructor"></a>Item 4 : Enforce noninstantiability with a private constructor</h2><p><strong>给不能实例化对象强制实现一个私有构造方法</strong></p><p>对于不需要实例化的类提供一个私有构造器（里面抛出异常等等处理）来避免被实例化，通常是对于一些接口，使接口抽象是不可取的因为可以被继承然后实例化。</p><p>这样做不好的一点就是无法被继承。</p><h2 id="Item-5-Prefer-dependency-injection-to-hardwiring-resources"><a href="#Item-5-Prefer-dependency-injection-to-hardwiring-resources" class="headerlink" title="Item 5 : Prefer dependency injection to hardwiring resources"></a>Item 5 : Prefer dependency injection to hardwiring resources</h2><p><strong>优先依赖注入底层资源</strong></p><p>静态聚合工具类（接口）和单例不适合依赖参数实例化的场景，简单说就是不要用单例或者是静态聚合类（接口）去实现一个依赖除自身的类，<br>并且不要用类直接去创建这些资源，传递给构造器（builder工厂方法）去处理，提升类的灵活性、可重用性和可测试性。</p><p>这种情况下需要将参数传递给构造器来实例化（依赖注入模式）<br>这种方式的一个变种是传入一个 factory 给构造器，这个 factory 可以重复的返回对象实例（Factory Method pattern）</p><p>Java8中的 Supplier<t>就是 factory 一个很好的代表。<br>传入构造器的最好是一个通配的类型以便于扩展：</t></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Mosaic <span class="hljs-title function_">create</span><span class="hljs-params">(Supplier&lt;? extends Tile&gt; tileFactory)</span> &#123; ... &#125;<br></code></pre></td></tr></table></figure><h2 id="Item-6-Avoid-creating-unnecessary-objects"><a href="#Item-6-Avoid-creating-unnecessary-objects" class="headerlink" title="Item 6 : Avoid creating unnecessary objects"></a>Item 6 : Avoid creating unnecessary objects</h2><p><strong>避免创建不必要的对象</strong></p><ul><li>适当的重用对象</li><li>避免创建无用的和重复的对象</li><li>可通过静态工厂方法来避免创建不必要的对象</li><li>有时候在调用工厂方法的时候不希望某个final属性被初始化而是当调用涉及到的方法的时候才初始化（后面会有提到），这样做性能提升不明显</li><li>多使用基本数据类型，小心隐藏的自动拆装箱带来的性能损耗<br>比如下面的代码：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">long</span> <span class="hljs-title function_">sum</span><span class="hljs-params">()</span> &#123;<br>           <span class="hljs-type">Long</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0L</span>;<br>           <span class="hljs-keyword">for</span> (<span class="hljs-type">long</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt;= Integer.MAX_VALUE; i++)<br>               sum += i;<br>           <span class="hljs-keyword">return</span> sum;<br>   &#125;<br></code></pre></td></tr></table></figure>如果上面sum改成long性能会提升巨大</li></ul><h2 id="Item-7-Eliminate-obsolete-object-references"><a href="#Item-7-Eliminate-obsolete-object-references" class="headerlink" title="Item 7 : Eliminate obsolete object references"></a>Item 7 : Eliminate obsolete object references</h2><p><strong>及时处理过期对象引用</strong></p><ul><li>无意的对象引用保留可能会造成gc无法回收，内存泄露，无用对象直接置空即可（null）</li><li>不管任何时候，只要是一个类自己管理内存，程序员都要小心内存泄露（数组等等）</li></ul><p>缓存可能造成内存泄漏(无用对象没有及时被回收)</p><ol><li>使用WeakHashMap</li><li>启用一个后台进程去清理过期缓存</li></ol><p>监听器和其他回调可能导致内存泄露</p><ol><li>可以使用 weak references 将其放入 WeakHashMap</li></ol><p>内存泄露往往不是立刻发生，而是可能潜伏在系统多年，只有发生了才会体现出来，可以使用 <a target="_blank" rel="noopener" href="http://goog-perftools.sourceforge.net/doc/heap_profiler.html">http://goog-perftools.sourceforge.net/doc/heap_profiler.html</a> 来帮助分析</p><h2 id="Item-8-Avoid-finalizers-and-cleaners"><a href="#Item-8-Avoid-finalizers-and-cleaners" class="headerlink" title="Item 8 : Avoid finalizers and cleaners"></a>Item 8 : Avoid finalizers and cleaners</h2><p><strong>避免使用 finalizer 和 cleaner</strong></p><ul><li>Java9中finalizers被cleaners替代，finalizer和cleaner不能保证被及时执行</li><li>绝对不要在finalizer和cleaner中做一些关键操作，比如关闭文件</li><li>不要依赖finalizer和cleaner修改一些持久状态，比如释放公共资源的锁<br>System.gc和System.runFinalization两个方法虽然会增加finalizer和cleaner被执行的几率但是并不能保证，<br>只保证System.runFinalizersOnExit和Runtime.runFinalizersOnExit肯定被执行，但是后面的两种方法已经被弃用。</li><li>finalization过程中抛出的未捕获异常被忽略，导致对象的finalization终止，cleaner没有这个问题因为cleaner可以自己控制进程</li><li>使用finalizers和cleaners有严重的性能缺陷</li><li>finalizers有一个严重的安全问题：容易被 finalizer 攻击<br>如果构造器或者与序列化等价的方法（比如 readObject, readResolve）抛出异常，一个恶意子类的 finalizer 可以运行在部分构建的实例上，<br>这个恶意子类可以引用通过一个静态属性引用父类防止父类被gc回收，一旦这个引用成功，那就很容易执行父类中并不允许存在的方法。<br>解决：只需提供一个final finalize 空方法即可</li></ul><p>可以实现 AutoCloseable 来代替finalizer和cleaner，然后实现其 close 方法即可，每个实例不再使用调用该方法即可，一般使用 try-with-resources 来确保万一。<br>值得一提的是，这种类最好有一个字段来记录一个实例是否被 close ，如果不小在实例已经被 closed 之后再次调用，记得抛出 IllegalStateException 异常。</p><p>finalizers和cleaners两个正确的用法：</p><ol><li>资源占用着忘记调用上面提到的 close 方法来释放资源，虽然也并不能保证 finalizer 和 cleaner及时执行，但总比什么都不做好，但也需要考虑性能的缺失是否值得</li><li>处理 native peers， 因为 native peer 不是普通的java对象，所以gc不知道它也无法回收它，而finalizers和cleaners适合来完成这个任务</li></ol><p>总的来说不要使用 cleaners 或者不要使用 Java9之前的 cleaners；<br>不要使用 finalizers ，除非需要安全操作或者关闭重要资源，并且留意他们的不确定性和性能。</p><h2 id="Item-9-Prefer-try-with-resources-to-try-finally"><a href="#Item-9-Prefer-try-with-resources-to-try-finally" class="headerlink" title="Item 9 : Prefer try-with-resources to try-finally"></a>Item 9 : Prefer try-with-resources to try-finally</h2><p><strong>优先使用 try-with-resources 而不是 try-finally</strong></p><p>Java中有很多的资源需要手动释放，执行 close 方法即可，比如 InputStream,BufferedReader 等等，他们都直接或者间接的实现了 AutoCloseable 接口。</p><p>使用需要释放的资源时尽可能用 try-with-resources ，可以提升代码可读性，更加简洁清楚，异常堆栈信息更有利于排查bug，比如下面的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">BUFFER_SIZE</span> <span class="hljs-operator">=</span> <span class="hljs-number">16</span>;<br><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">copy</span><span class="hljs-params">(String src, String dst)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-type">InputStream</span> <span class="hljs-variable">in</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(src);<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-type">OutputStream</span> <span class="hljs-variable">out</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(dst);<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">byte</span>[] buf = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[BUFFER_SIZE];<br>            <span class="hljs-type">int</span> n;<br>            <span class="hljs-keyword">while</span> ((n = in.read(buf)) &amp;gt;= <span class="hljs-number">0</span>)<br>                out.write(buf, <span class="hljs-number">0</span>, n);<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            out.close();<br>        &#125;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        in.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">BUFFER_SIZE</span> <span class="hljs-operator">=</span> <span class="hljs-number">16</span>;<br><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">copy</span><span class="hljs-params">(String src, String dst)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-keyword">try</span> (<span class="hljs-type">InputStream</span> <span class="hljs-variable">in</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(src); <span class="hljs-type">OutputStream</span> <span class="hljs-variable">out</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(dst)) &#123;<br>        <span class="hljs-type">byte</span>[] buf = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[BUFFER_SIZE];<br>        <span class="hljs-type">int</span> n;<br>        <span class="hljs-keyword">while</span> ((n = in.read(buf)) &amp;gt;= <span class="hljs-number">0</span>) &#123;<br>            out.write(buf, <span class="hljs-number">0</span>, n);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以明显看到使用try-with-resources 代码简洁很多，更加清楚。</p><blockquote class="copyright"><p>本站所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">BY-NC-SA 4.0</a> 许可协议。转载请注明出处！</p></blockquote></main><nav class="pagination"><span class="prev"><a href="/posts/305">EFFECTIVE JAVA 3RD EDITION — 第三章 对象基本方法 </a></span><span class="next"><a href="/posts/302">JAVA 9 新特性 — HTTP2</a></span></nav><script src="/js/main.js"></script><footer><p class="socials"><a href="https://github.com/lostars" target="_blank"><svg class="fontawesome-icon"><use href="/icons/fontawesome.svg#github"></use></svg> </a><a href="https://open.spotify.com/user/boyizmen" target="_blank"><svg class="fontawesome-icon"><use href="/icons/fontawesome.svg#spotify"></use></svg> </a><a href="https://space.bilibili.com/20516992" target="_blank"><svg class="fontawesome-icon"><use href="/icons/fontawesome.svg#bilibili"></use></svg> </a><input type="hidden" id="emailUser" value="bW9tbw=="> <input type="hidden" id="emailDomain" value="bWluZWkubWU="> <a id="emailLink" href="#" target="_blank"><svg class="fontawesome-icon"><use href="/icons/fontawesome.svg#email"></use></svg></a></p><p>Build with ❤ I abandon here my love</p><p>Copyright &copy; 2025 boyizmen</p></footer></body></html>