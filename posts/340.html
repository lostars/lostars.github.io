<!DOCTYPE html><html><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><link rel="shortcut icon" href="/images/blog/favicon.svg"><meta name="keywords" content=""><meta name="description" content=""><link rel="stylesheet" href="/styles/main.css"><link rel="stylesheet" href="/styles/post.css"><title>EFFECTIVE JAVA 3RD EDITION — 第五章 泛型 - Daydream</title><meta name="generator" content="Hexo 7.3.0"></head><body><header><nav><ul><li><a href="/">Home</a></li><li><a href="/posts/"><span>Posts</span></a></li><li><a href="/categories/"><span>Categories</span></a></li><li><a href="/about"><span>About</span></a></li></ul></nav></header><main><header><h1>EFFECTIVE JAVA 3RD EDITION — 第五章 泛型</h1><div><time>2018-05-02</time><div class="post-categories"><span class="category-tree"><span class="category-separator">/</span> <a href="/categories/dev/">dev</a></span></div><div class="post-tags"><span class="tag"><span class="category-separator">#</span> <a href="/tags/effective-java-3rd/">effective-java-3rd</a></span></div></div></header><h2 id="Item-26-Don’t-use-raw-types"><a href="#Item-26-Don’t-use-raw-types" class="headerlink" title="Item 26 : Don’t use raw types"></a>Item 26 : Don’t use raw types</h2><p><strong>不要使用原始类型（没有类型声明的泛型）</strong></p><p>因为编译器无法知道你的一个集合装的是什么，比如下面的代码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-type">List</span> <span class="hljs-variable">list</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>();<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addE</span><span class="hljs-params">(Object o)</span> &#123;<br>    list.add(o); <span class="hljs-comment">// got a unchecked warning</span><br>&#125;<br></code></pre></td></tr></table></figure><p>上面代码在编译期间是不会报错的，只有当你获取元素进行类型转换的时候会抛出类转换异常，所以最好的方式就是像下面一样写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> List&lt;String&gt; strList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addE</span><span class="hljs-params">(Object o)</span> &#123;<br> strList.add(o); <span class="hljs-comment">// 编译无法通过</span><br>&#125;<br></code></pre></td></tr></table></figure><p>编译器就会知道集合中应该装什么类型，在编译期间就会抛出异常，并且保证集合中的元素都是合法的元素。</p><p>ps : 不要忽略任何警告(检查警告等)</p><p>有时候我们不需要关心集合元素本身，比如比较两个Set集合中相同元素个数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">numElementsInCommon</span><span class="hljs-params">(Set s1, Set s2)</span> &#123;...&#125;<br></code></pre></td></tr></table></figure><p>这种情况最好使用通配类型，比如:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">numElementsInCommon</span><span class="hljs-params">(Set&lt;?&gt; s1, Set&lt;?&gt; s2)</span> &#123; ... &#125;<br></code></pre></td></tr></table></figure><p>Set&lt;?&gt;就代表了任意类型，由此来保证类型安全和灵活性.</p><h2 id="Item-27-Eliminate-unchecked-warnings"><a href="#Item-27-Eliminate-unchecked-warnings" class="headerlink" title="Item 27 : Eliminate unchecked warnings"></a>Item 27 : Eliminate unchecked warnings</h2><p><strong>解决未检查警告</strong></p><p>如果能够保证类型安全可以使用 SuppressWarnings(“unchecked”) 来忽略未检查警告，但尽可能使用小的范围.</p><p>无法在return上使用该注解，可以使用一个局部变量来使用使用这个注解<br>使用该注解之后记得加注释说明为什么</p><h2 id="Item-28-Prefer-lists-to-arrays"><a href="#Item-28-Prefer-lists-to-arrays" class="headerlink" title="Item 28 : Prefer lists to arrays"></a>Item 28 : Prefer lists to arrays</h2><p><strong>使用集合而不是数组</strong></p><ol><li>数组是协变的：如果Sub是Super的子类，那么Sub[]也是Super[]的子类；而泛型则是不变的<br>如果你往一个String的容器里放入Long，数组会在运行时报错，而泛型则会在编译时报错</li><li>数组是具体化的，也就是说会在运行时期强行类型检查；而泛型则会在编译时期进行类型检查，在运行时期忽略或者擦除（erasure）类型信息<br>泛型的这种特性为Java5以前的代码过度到泛型提供了方便<br>泛型数组的创建是不合法的：</li><li>类型不安全</li><li>当在可变参数方法中使用泛型时会收到警告，因为可变参数也是由一个数组保存的，可以使用 SafeVarargs 注解</li><li>如果收到一个泛型数组创建错误或者类型转换检查警告可以将数组转换成List，虽然可能会丢失一些性能但是保证了类型安全，比如:</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Chooser</span>&lt;T&gt; &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> T[] choiceArray;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Chooser</span><span class="hljs-params">(Collection&lt;T&gt; choices)</span> &#123;<br>        choiceArray = choices.toArray();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以使用List来替换数组:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Chooser</span>&lt;T&gt; &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> List&lt;T&gt; choiceList;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Chooser</span><span class="hljs-params">(Collection&lt;T&gt; choices)</span> &#123;<br>        choiceList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(choices);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>总的来说数组提供了运行时类型安全而不是编译时类型安全，而泛型则刚好相反，搞不清或者为了安全最好使用List而不是数组</p><h2 id="Item-29-Favor-generic-types"><a href="#Item-29-Favor-generic-types" class="headerlink" title="Item 29 : Favor generic types"></a>Item 29 : Favor generic types</h2><p><strong>偏向使用通用类型</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Stack</span>&lt;E&gt; &#123;<br>    <span class="hljs-keyword">private</span> E[] elements;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">DEFAULT_INITIAL_SIZE</span> <span class="hljs-operator">=</span> <span class="hljs-number">16</span>;<br> <br>    <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Stack</span><span class="hljs-params">()</span> &#123;<br>        elements = (E[]) <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[DEFAULT_INITIAL_SIZE];<br>    &#125;<br> <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">push</span><span class="hljs-params">(E e)</span> &#123;<br>        <span class="hljs-comment">// ensure capacity ...</span><br>        elements[size++] = e;<br>    &#125;<br> <br>    <span class="hljs-keyword">public</span> E <span class="hljs-title function_">pop</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (size == <span class="hljs-number">0</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">EmptyStackException</span>();<br>        <span class="hljs-type">E</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> elements[--size];<br>        elements[size] = <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>    <span class="hljs-comment">// other operation in Stack ...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>上面的代码中我们用E替换了Object，在构造器中由于不能使用泛型数组这里进行了强制类型转换，并且保证唯一一处数组初始化的时候类型安全，所以用 SuppressWarnings<br>泛型比需要在代码中强制类型转换的更为简单和安全，当你设计新类型并且需要类型转换的时候考虑泛型</p><h2 id="Item-30-Favor-generic-methods"><a href="#Item-30-Favor-generic-methods" class="headerlink" title="Item 30 : Favor generic methods"></a>Item 30 : Favor generic methods</h2><p><strong>偏向使用通用方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;E <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Comparable</span>&lt;E&gt;&gt; E <span class="hljs-title function_">max</span><span class="hljs-params">(Collection&lt;E&gt; c)</span> &#123;<br>    <span class="hljs-keyword">if</span> (c.isEmpty())<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;Empty collection&quot;</span>);<br>    <span class="hljs-type">E</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">for</span> (E e : c)<br>        <span class="hljs-keyword">if</span> (result == <span class="hljs-literal">null</span> || e.compareTo(result) &gt; <span class="hljs-number">0</span>)<br>            result = Objects.requireNonNull(e);<br> <br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面的代码说明了:</p><ol><li>只有实现了Comparable接口才能进行比较</li><li>只能同类型进行比较<br>上面代码会抛出异常，可以返回一个Optional<e>，泛型方法和泛型有同样的优点</e></li></ol><h2 id="Item-31-Use-bounded-wildcards-to-increase-API-flexibility"><a href="#Item-31-Use-bounded-wildcards-to-increase-API-flexibility" class="headerlink" title="Item 31 : Use bounded wildcards to increase API flexibility"></a>Item 31 : Use bounded wildcards to increase API flexibility</h2><p><strong>使用限定通配符来增加API灵活性</strong></p><p>比如一个Stack的pushAll方法:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">pushAll</span><span class="hljs-params">(Iterable&lt;E&gt; src)</span> &#123;<br>    <span class="hljs-keyword">for</span> (E e : src)<br>       push(e);<br>&#125;<br>Stack&lt;Number&gt; numberStack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;();<br>Iterable&lt;Integer&gt; integers = ... ;<br>numberStack.pushAll(integers);<br></code></pre></td></tr></table></figure><p>看起来是没什么问题，但是会出现错误，因为参数类型是不变的，虽然Integer继承了Number但是编译器不知道，这个时候就需要限定通配类型来解决（bounded widlcard type）:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">pushAll</span><span class="hljs-params">(Iterable&lt;? extends E&gt; src)</span> &#123;<br>    <span class="hljs-keyword">for</span> (E e : src)<br>        push(e);<br>&#125;<br></code></pre></td></tr></table></figure><p>又比如另外一个例子:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">popAll</span><span class="hljs-params">(Collection&lt;E&gt; dst)</span> &#123;<br>    <span class="hljs-keyword">while</span> (!isEmpty())<br>        dst.add(pop());<br>&#125;<br>Stack&lt;Number&gt; numberStack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;Number&gt;();<br>Collection&lt;Object&gt; objects = ... ;<br>numberStack.popAll(objects);<br></code></pre></td></tr></table></figure><p>这里会出现类似的错误，因为编译器认为 Collection&lt;Object&gt; 不是Collection&lt;Number&gt; 的子类，这里就可以作类似的修改:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">popAll</span><span class="hljs-params">(Collection&lt;? <span class="hljs-built_in">super</span> E&gt; dst)</span> &#123;<br>    <span class="hljs-keyword">while</span> (!isEmpty())<br>        dst.add(pop());<br>&#125;<br></code></pre></td></tr></table></figure><p>到这里就会有一个疑问了，到底什么时候用 extends 什么时候用 super？</p><p>通常在输入参数中用生产者和消费者来最大化灵活性：<br>如果是生产者用 extends 消费者用 super</p><p>比如上面的例子中pushAll方法是生产 E 实例，那么就用 extends，popAll方法消费实例就用 super</p><p>需要注意的是虽然输入参数使用了限定通配符但是返回类型不要使用，即不要有Set&lt;? extends E&gt;这样的返回值</p><p>当使用者需要去考虑统配类型的时候说明API的设计是有问题的</p><p>另外一个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Comparable</span>&lt;T&gt;&gt; T <span class="hljs-title function_">max</span><span class="hljs-params">(List&lt;T&gt; list)</span><br></code></pre></td></tr></table></figure><p>按照前面的规则，该方法产生集合最大值是生产者，所以参数可以修改为 List&lt;? extends T&gt;, 这里返回值依旧是 T</p><p>同时 Comparable也是消费者，所以修改为下面:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Comparable</span>&lt;? <span class="hljs-built_in">super</span> T&gt;&gt; T <span class="hljs-title function_">max</span><span class="hljs-params">(List&lt;? extends T&gt; list)</span><br></code></pre></td></tr></table></figure><p>Comparable通常都是消费者，所以通配都可以写成 Comparable&lt;? super T&gt;, Comparator&lt;? super T&gt;</p><h2 id="Item-32-Combine-generics-and-varargs-judiciously"><a href="#Item-32-Combine-generics-and-varargs-judiciously" class="headerlink" title="Item 32 : Combine generics and varargs judiciously"></a>Item 32 : Combine generics and varargs judiciously</h2><p><strong>结合泛型和可变参数</strong></p><p>Heap Pollution（堆污染）:<br>指一个参数化的变量所引用的并不是他本身的类型</p><p>这就很可能会造成 ClassCastException，比如下面的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dangerous</span><span class="hljs-params">(List&lt;String&gt;... stringLists)</span> &#123;<br>    List&lt;Integer&gt; intList = List.of(<span class="hljs-number">42</span>);<br>    Object[] objects = stringLists;<br>    objects[<span class="hljs-number">0</span>] = intList; <span class="hljs-comment">// Heap pollution</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> stringLists[<span class="hljs-number">0</span>].get(<span class="hljs-number">0</span>); <span class="hljs-comment">// ClassCastException</span><br>&#125;<br></code></pre></td></tr></table></figure><p>所以在可变参数数组中存储是不安全的</p><p>我们使用SafeVarargs注解来保证一个方法是类型安全的，通常通用可变参数方法都会有警告提示可能会有堆污染</p><p>再来看下面的例子:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> &lt;T&gt; T[] toArray(T... args) &#123;<br>    <span class="hljs-keyword">return</span> args;<br>&#125;<br></code></pre></td></tr></table></figure><p>乍看是没有问题的，因为这个方法只是作了一个参数传递，那么看下面的调用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> &lt;T&gt; T[] pickTwo(T a, T b, T c) &#123;<br>    <span class="hljs-keyword">switch</span>(ThreadLocalRandom.current().nextInt(<span class="hljs-number">3</span>)) &#123;<br>         <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>: <span class="hljs-keyword">return</span> toArray(a, b);<br>         <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>: <span class="hljs-keyword">return</span> toArray(a, c);<br>         <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>: <span class="hljs-keyword">return</span> toArray(b, c);<br>    &#125;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AssertionError</span>(); <span class="hljs-comment">// Can&#x27;t get here</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这个调用看起来也是没什么毛病，但是执行 toArray方法之后就会报 ClassCastException，因为 toArray的返回类型是由传入的参数决定的，<br>编译器是无法精确的预测具体类型，所以在 pickTwo方法中会统一返回 Object[] 数组，但是pickTwo方法传入的是String，所以返回也应该是String数组，<br>这里隐藏了一个类型转换并且转换失败了。</p><p>上面的例子说明了把可变参数传递到另一个方法是不安全的。</p><p>但是在Java 9 中 List.of()方法源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SafeVarargs</span><br><span class="hljs-meta">@SuppressWarnings(&quot;varargs&quot;)</span><br><span class="hljs-keyword">static</span> &lt;E&gt; List&lt;E&gt; <span class="hljs-title function_">of</span><span class="hljs-params">(E... elements)</span> &#123;<br>	<span class="hljs-keyword">switch</span> (elements.length) &#123; <span class="hljs-comment">// implicit null check of elements</span><br>        <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">return</span> ImmutableCollections.List0.instance();<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ImmutableCollections</span>.List1&lt;&gt;(elements[<span class="hljs-number">0</span>]);<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ImmutableCollections</span>.List2&lt;&gt;(elements[<span class="hljs-number">0</span>], elements[<span class="hljs-number">1</span>]);<br>        <span class="hljs-keyword">default</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ImmutableCollections</span>.ListN&lt;&gt;(elements);<br>    &#125;        <br>&#125;<br></code></pre></td></tr></table></figure><p>ListN方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SafeVarargs</span><br>ListN(E... input) &#123;<br>    <span class="hljs-comment">// copy and check manually to avoid TOCTOU</span><br>    <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br>    E[] tmp = (E[])<span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[input.length]; <span class="hljs-comment">// implicit nullcheck of input</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; input.length; i++) &#123;<br>        tmp[i] = Objects.requireNonNull(input[i]);<br>    &#125;<br>    <span class="hljs-built_in">this</span>.elements = tmp;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到用的是 Object[] 数组然后再作的类型转换，这里保证了类型安全</p><p>通用变长参数一个典型用法:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SafeVarargs</span><br><span class="hljs-keyword">static</span> &lt;T&gt; List&lt;T&gt; <span class="hljs-title function_">flatten</span><span class="hljs-params">(List&lt;? extends T&gt;... lists)</span> &#123;<br>    List&lt;T&gt; result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-keyword">for</span> (List&lt;? <span class="hljs-keyword">extends</span> <span class="hljs-title class_">T</span>&gt; list : lists)<br>        result.addAll(list);<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><p>SafeVarargs需要加在每一个通用变长方法上来保证类型安全，但是我们可以按照 Item28 来进行修改，不用变长参数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> &lt;T&gt; List&lt;T&gt; <span class="hljs-title function_">flatten</span><span class="hljs-params">(List&lt;List&lt;? extends T&gt;&gt; lists)</span> &#123;<br>    List&lt;T&gt; result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-keyword">for</span> (List&lt;? <span class="hljs-keyword">extends</span> <span class="hljs-title class_">T</span>&gt; list : lists)<br>        result.addAll(list);<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Item-33-Consider-typesafe-heterogeneous-containers"><a href="#Item-33-Consider-typesafe-heterogeneous-containers" class="headerlink" title="Item 33 : Consider typesafe heterogeneous containers"></a>Item 33 : Consider typesafe heterogeneous containers</h2><p><strong>考虑使用封装好的类型安全的容器</strong></p><p>比如 ThreadLocal&lt;T&gt;, AtomicReference&lt;T&gt;等等</p><p>在使用一些封装好了的类型安全的容器(集合框架)的时候其实限制了我们的参数个数，但是我们可以用 Class 对象来作为这些容器的key，这样的 Class 被叫做 type token</p><blockquote class="copyright"><p>本站所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">BY-NC-SA 4.0</a> 许可协议。转载请注明出处！</p></blockquote></main><nav class="pagination"><span class="prev"><a href="/posts/342">JAVA 8 DURATION 详解 </a></span><span class="next"><a href="/posts/319">EFFECTIVE JAVA 3RD EDITION — 第四章 类与接口（2）</a></span></nav><script src="/js/main.js"></script><footer><p class="socials"><a href="https://github.com/lostars" target="_blank"><svg class="fontawesome-icon"><use href="/icons/fontawesome.svg#github"></use></svg> </a><a href="https://open.spotify.com/user/boyizmen" target="_blank"><svg class="fontawesome-icon"><use href="/icons/fontawesome.svg#spotify"></use></svg> </a><a href="https://space.bilibili.com/20516992" target="_blank"><svg class="fontawesome-icon"><use href="/icons/fontawesome.svg#bilibili"></use></svg> </a><input type="hidden" id="emailUser" value="bW9tbw=="> <input type="hidden" id="emailDomain" value="bWluZWkubWU="> <a id="emailLink" href="#" target="_blank"><svg class="fontawesome-icon"><use href="/icons/fontawesome.svg#email"></use></svg></a></p><p>Build with ❤ I abandon here my love</p><p>Copyright &copy; 2025 boyizmen</p></footer></body></html>