<!DOCTYPE html><html><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><link rel="shortcut icon" href="/images/blog/favicon.svg"><meta name="keywords" content=""><meta name="description" content=""><link rel="stylesheet" href="/styles/main.css"><link rel="stylesheet" href="/styles/post.css"><title>EFFECTIVE JAVA 3RD EDITION — 第九章 日常编程 - Daydream</title><meta name="generator" content="Hexo 7.3.0"></head><body><header><nav><ul><li><a href="/">Home</a></li><li><a href="/posts/"><span>Posts</span></a></li><li><a href="/categories/"><span>Categories</span></a></li><li><a href="/about"><span>About</span></a></li></ul></nav></header><main><header><h1>EFFECTIVE JAVA 3RD EDITION — 第九章 日常编程</h1><div><time>2019-01-14</time><div class="post-categories"><span class="category-tree"><span class="category-separator">/</span> <a href="/categories/dev/">dev</a></span></div><div class="post-tags"><span class="tag"><span class="category-separator">#</span> <a href="/tags/effective-java-3rd/">effective-java-3rd</a></span></div></div></header><h2 id="Item-57-Minimize-the-scope-of-local-variables"><a href="#Item-57-Minimize-the-scope-of-local-variables" class="headerlink" title="Item 57 : Minimize the scope of local variables"></a>Item 57 : Minimize the scope of local variables</h2><p><strong>最小化局部变量的作用域</strong></p><ol><li>在使用的地方声明局部变量，过早的声明会导致代码块过早开始过晚结束；</li><li>让方法保持精简，集中于某一些逻辑，如果方法太大分成两个方法；</li><li>使用for循环而不是使用while循环；<br>声明局部变量时便初始化。 同时偏向于使用for循环而不是while循环，使用while循环会造成一些复制粘贴错误，比如：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java">Iterator&lt;Element&gt; i = c.iterator();<br><span class="hljs-keyword">while</span> (i.hasNext()) &#123;<br>    doSomething(i.next());<br>&#125;<br>...<br>Iterator&lt;Element&gt; i2 = c2.iterator();<br><span class="hljs-keyword">while</span> (i.hasNext()) &#123; <span class="hljs-comment">// BUG!</span><br>    doSomethingElse(i2.next());<br>&#125;<br></code></pre></td></tr></table></figure><p>上面的代码编译运行都不会有任何问题，就是因为变量i的作用域太广了，导致后面的while循环也可以使用，如果使用for循环：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span> (Iterator&lt;Element&gt; i = c.iterator(); i.hasNext(); ) &#123;<br><span class="hljs-type">Element</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> i.next();<br>    ... <span class="hljs-comment">// Do something with e and i</span><br>&#125;<br>...<br><span class="hljs-comment">// Compile-time error - cannot find symbol i</span><br><span class="hljs-keyword">for</span> (Iterator&lt;Element&gt; i2 = c2.iterator(); i.hasNext(); ) &#123;<br>    <span class="hljs-type">Element</span> <span class="hljs-variable">e2</span> <span class="hljs-operator">=</span> i2.next();<br>    ... <span class="hljs-comment">// Do something with e2 and i2</span><br>&#125;<br></code></pre></td></tr></table></figure><p>代码在编译时就会出现问题，同时for循环代码也更简洁一点。</p><h2 id="Item-58-Prefer-for-each-loops-to-traditional-for-loops"><a href="#Item-58-Prefer-for-each-loops-to-traditional-for-loops" class="headerlink" title="Item 58 : Prefer for-each loops to traditional for loops"></a>Item 58 : Prefer for-each loops to traditional for loops</h2><p><strong>偏向使用for-each循环而不是传统for循环</strong></p><p>由于传统的for循环和迭代器会涉及到数组下标或者是是否还有元素的问题，在更关注元素本身的情况下使用for-each会让代码更加简洁，同时避免bug出现的几率。下面三种情况不适合使用foreach：</p><ol><li>操作集合本身的一些过滤，比如添加或者删除元素，这些都需要数组下标来支持，或者使用迭代器；</li><li>转换，替换集合或者数组的元素等操作；</li><li>并行迭代，并行操作多个集合的时候由于需要控制循环的次数和数组下标来避免数组越界；<br>foreach支持循环所有实现Iterable接口的对象，总的来说就是如果更加关注循环元素本身并且不需要操作集合元素（删除等等）的话使用foreach。</li></ol><h2 id="Item-59-Know-and-use-the-libraries"><a href="#Item-59-Know-and-use-the-libraries" class="headerlink" title="Item 59 :  Know and use the libraries"></a>Item 59 : Know and use the libraries</h2><p><strong>了解并使用库</strong></p><p>使用标准库可以充分利用开发者和其他人的经验，避免踩坑。java7之后的随机数生成器使用ThreadLocalRandom，性能会提升很多。而对fork join和并行流则可以使用SplittableRandom。<br>使用标准库的好处：</p><ol><li>不需要自己去实现，标准库的发布都是经过了严格的测试和性能测试，就算有bug或者需要功能更新会有新的版本来发布;</li><li>不用花时间去造轮子，专心于业务本身节约时间；</li><li>标准库的性能会随着版本更新而提高，毕竟是工业级的产品，不需要担心他的性能和更新问题；</li><li>功能性的更新会随着版本更新到来，如果没有需要的功能可以在开发社区进行反馈；</li><li>使用标准库可以让你的代码更为‘主流’，可以学习标准库的实现方式和代码风格；<br>由于开发人员并不知道每次更新加入的新功能和特性，尽管有上面那么多的好处，但是却很少开发人员这样做。所以需要对版本的更迭和新特性保持持续关注，同时也需要对java标准类库的熟悉：java.utl java.lang java.io及其子包。</li></ol><p>通常开发中如果Java标准类库中没有可用功能可以寻找第三方的类库，如果还是没有则自己实现。不要重复造轮子！！！</p><h2 id="Item-60-Avoid-float-and-double-if-exact-answers-are-required"><a href="#Item-60-Avoid-float-and-double-if-exact-answers-are-required" class="headerlink" title="Item 60 : Avoid float and double if exact answers are required"></a>Item 60 : Avoid float and double if exact answers are required</h2><p><strong>避免在需要返回具体值的地方使用float和double</strong></p><p>通常float和double用来做科学和工程计算的，都用于浮点计算，并且在货币计算上面很难使用。正确的货币计算应该使用int long或者BigDecimal，但BigDecimal使用上比基本类型麻烦，或者在货币计算中统一使用最小的货币单位来进行计算。</p><p>总的来说就是在需要具体值的时候不使用double和float，根据实际的数据长度来选择使用int long或者BigDecimal。</p><h2 id="Item-61-Prefer-primitive-types-to-boxed-primitives"><a href="#Item-61-Prefer-primitive-types-to-boxed-primitives" class="headerlink" title="Item 61 : Prefer primitive types to boxed primitives"></a>Item 61 : Prefer primitive types to boxed primitives</h2><p><strong>偏向于使用基本类型而不是其包装类</strong></p><p>基本类型和其包装类型有几点不同：</p><ol><li>基本类型只有值，就算有相同值的包装类型也会有不同的特征（内部属性等）；</li><li>基本类型只有一个值，而包装类型可以有null这么一个值；</li><li>基本类型在时间和空间上比包装类型更好的性能；</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Broken comparator - can you spot the flaw?</span><br>Comparator&lt;Integer&gt; naturalOrder =<br>(i, j) -&gt; (i &lt; j) ? -<span class="hljs-number">1</span> : (i == j ? <span class="hljs-number">0</span> : <span class="hljs-number">1</span>);<br>naturalOrder.compare(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>(<span class="hljs-number">42</span>), <span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>(<span class="hljs-number">42</span>));<br></code></pre></td></tr></table></figure><p>上面的代码会返回1，因为第一次比较出现自动拆箱，42&#x3D;&#x3D;42，第二次比较&#x3D;&#x3D;但是却比较的是两个包装类返回false，所以包装类使用&#x3D;&#x3D;比较永远是错误的。</p><p>在混用包装类和基本类型的时候总是会出现包装类的自动拆箱，所以要非常小心包装类是否为null。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Hideously slow program! Can you spot the object creation?</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">Long</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0L</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">long</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; Integer.MAX_VALUE; i++) &#123;<br>        sum += i;<br>    &#125;<br>    System.out.println(sum);<br>&#125;<br></code></pre></td></tr></table></figure><p>上面代码结果输出没什么问题，但是性能上却很差，因为sum是一个包装类，而循环中的i是基本类型，循环中反复拆装箱导致性能问题。<br>但也有必须使用包装类的时候：</p><ul><li>集合框架中必须使用包装类；</li><li>作为参数类型也必须使用包装类，比如不能这样：List<int>；</int></li><li>在执行反射方法中必须使用包装类；<br>虽然自动拆装箱减少了很多麻烦，但是并没有代表其是安全的，正确的选择基本类型和包装类型来避免空指针和性能问题。</li></ul><h2 id="Item-62-Avoid-strings-where-other-types-are-more-appropriate"><a href="#Item-62-Avoid-strings-where-other-types-are-more-appropriate" class="headerlink" title="Item 62 :  Avoid strings where other types are more appropriate"></a>Item 62 : Avoid strings where other types are more appropriate</h2><p><strong>在可选的情况下避免使用String</strong></p><p>String本身的表达是不够强的，本身是设计用来表达字符本身的，对于其他类型的值就难以表达。枚举和其他聚合类都很难用String来代替，并且缺乏功能性。</p><p>总的来说避免使用String来代替其他类型，特别是误用在枚举、基本类型和聚合类中，这样使用不够灵活，慢，同时更容易出现问题。</p><h2 id="Item-63-Beware-the-performance-of-string-concatenation"><a href="#Item-63-Beware-the-performance-of-string-concatenation" class="headerlink" title="Item 63 : Beware the performance of string concatenation"></a>Item 63 : Beware the performance of string concatenation</h2><p><strong>留意字符连接的性能</strong></p><p>+拼接固定长度的字符尚可，但是如果出现在循环中就会造成严重的性能问题，这种情况可以使用StringBuilder，并且初始化长度。</p><h2 id="Item-64-Refer-to-objects-by-their-interfaces"><a href="#Item-64-Refer-to-objects-by-their-interfaces" class="headerlink" title="Item 64 :  Refer to objects by their interfaces"></a>Item 64 : Refer to objects by their interfaces</h2><p><strong>引用接口来代替引用实现类</strong></p><p>如果有合适的接口存在，最好把参数、返回、属性、变量都声明成接口类型。比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Good - uses interface as type</span><br>Set&lt;Son&gt; sonSet = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedHashSet</span>&lt;&gt;();<br></code></pre></td></tr></table></figure><p>而不是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Bad - uses class as type!</span><br>LinkedHashSet&lt;Son&gt; sonSet = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedHashSet</span>&lt;&gt;();<br></code></pre></td></tr></table></figure><p>习惯上面的会让代码更加灵活，同时可以快速的切换不同的实现。 但如果没有合适的接口或者要使用实现类中特有的功能那么还是引用原类型，比如String，Integer这种值对象是没有一个公共的接口的。</p><p>总的来说如果存在这么一个接口，同时又不依赖于某个实现特有的功能那么引用接口是更为合适的。</p><h2 id="Item-65-Prefer-interfaces-to-reflection"><a href="#Item-65-Prefer-interfaces-to-reflection" class="headerlink" title="Item 65 : Prefer interfaces to reflection"></a>Item 65 : Prefer interfaces to reflection</h2><p><strong>多使用接口而不是反射</strong></p><p>反射的不足：</p><ol><li>丢失了编译期的类型检查，包括异常检查，比如反射中执行一个不存在的方法只有在运行时才会抛出异常；</li><li>反射的代码笨拙难以阅读；</li><li>性能受到影响；</li></ol><p>适当的使用反射能够起到很好的效果，比如需要执行在编译期无法知道的类，就可以使用反射来创建对象，并且通过他的接口或者父类方法来操作。</p><p>在反射的代码中有很多检查异常，可以使用ReflectiveOperationException来捕获，它是反射异常的一个公共父类。</p><p>总的来说反射是个很强大的工具，但同时也有很多缺点，如果需要使用反射，最好只使用反射来初始化对象，对象的操作使用它的接口或者父类来处理。</p><h2 id="Item-66-Use-native-methods-judiciously"><a href="#Item-66-Use-native-methods-judiciously" class="headerlink" title="Item 66 :  Use native methods judiciously"></a>Item 66 : Use native methods judiciously</h2><p><strong>正确的使用本地方法</strong></p><p>Java本地方法（JNI）主要有3个用途：</p><ol><li>提供平台功能的访问；</li><li>提供本地方法的访问；</li><li>编写高性能的代码；<br>通常不建议使用本地方法来提高程序性能，使用本地方法是不安全的，因为使用本地方法的代码不在对内存问题免疫，本地方法比java本身更加依赖于平台；同时本地方法很难调试，如果不小心很可能降低性能，因为gc无法去处理本地方法的内存。</li></ol><p>总的来说谨慎使用本地方法，本地方法中一个小的bug可能导致程序的崩溃。</p><h2 id="Item-67-Optimize-judiciously"><a href="#Item-67-Optimize-judiciously" class="headerlink" title="Item 67 :  Optimize judiciously"></a>Item 67 : Optimize judiciously</h2><p><strong>正确的优化代码</strong></p><p>不要牺牲合理的设计和结构来交换性能，专注于编写好的程序而不是快的程序，但这并不是说就不需要考虑性能，实现可以修改和优化，但是架构本身的缺陷和漏洞除了重构无法优化。</p><p>努力避免限制性能的设计和代码，特别是API等等底层代码，这些代码后期的优化和修改十分困难，并且影响很大。设计时多考虑性能上的问题，比如使用接口而不是实现类，不然就会把自己绑定到实现类上，从而忽略了性能更好的实现。</p><p>不要为了性能而去封装性能差的API，API性能差可以随着版本迭代而修复，但是你封装的代码却永远是这样。</p><p>优化代码的前后都需要测试性能，往往你想要优化的代码不会有什么性能提升甚至性能会更差，所以每一个优化都需要进行前后对比。如果你的代码用了不同的实现或者需要跑在不同的硬件平台上，你需要更多的时间去优化程序性能。</p><p>总的来说就是专注于编写好的代码，同时注意性能问题，但是编写API或者其他底层公共代码则需要考虑性能问题；测试性能，如果代码性能不够好，定位耗时的代码并且优化它，每一个优化都一定要经过测试。</p><h2 id="Item-68-Adhere-to-generally-accepted-naming-conventions"><a href="#Item-68-Adhere-to-generally-accepted-naming-conventions" class="headerlink" title="Item 68 : Adhere to generally accepted naming conventions"></a>Item 68 : Adhere to generally accepted naming conventions</h2><p><strong>命名规范</strong></p><p>JAVA有两类命名规范：排版规范和语法规范， 打破命名规范会让代码变得难以阅读和掌握，同时可能会引起误解。</p><p>排版规范：</p><ul><li>包和模块命名用.分隔，同时要是小写字母，名称不要太长一个单词最好，能够体现出这个包的作用，如果是公开的API需要用企业的域名倒置，比如：com.google，同时应该避免以java或者javax开头的包命名；</li><li>类和接口的名字，包括枚举和注解都应该由一个或多个单词组成，每个单词首字母大写，也可以是缩略词；</li><li>方法和属性命名和类类似，不同就是首字母不用大写，如果缩略词是第一个单词应该小写；</li><li>常量则应该是用下划线连接的大写单词；</li><li>局部变量命名则相对独立和宽松。方法入参则是一种特殊的局部变量，它的命名需要格外注意，因为他们会出现在文档中；</li><li>类型参数则只用一个单独字母表示，大部分都是下面几种：<br>T 代表任意类型，E代表集合的元素，K，V则代表Map的key和value，X代表异常，R代表返回值，一组类型通常用T,U,V或者T1,T2,T3。<br>语法规范：</li><li>可实例化的类包括枚举命名都是由一个名词或者名词短语构成，比如 Thread,PriorityQueue，而不可实例化的类通常是由复数形式的名词构成，比如Collectors,Collections；</li><li>接口命名则和类相同，或者有一个形容词结尾，比如Runnable,Iterable；</li><li>方法命名则通常都是由动词或者动词短语构成，比如append,drawImage，返回布尔值的方法通常以is或者has开头，紧跟一个名词，名词短语，或者是其他任何作为形容词的单词或者短语，比isDigit,isProbablePrime<br>非布尔返回值的方法则通常用名词，名词短语或者是动词短语，并且用get开头，比如size,hashCode,getTime<br>另外一些特别的方法命名需要注意，比如类型的转换toString,toArray等等，或者返回了一个和入参不相同的类型，比如asList等等，返回基本类型的通常以typeValue命名，比如intValue，而针对静态工厂方法则通常用from,of,valueOf,instance,getInstance,newInstance等等命名；<br>总的来说，学习标准的命名并深入了解和使用，排版规范更直接和清楚，语法规范则更为复杂和宽松。</li></ul><hr><p>这一章很贴近平时编程从代码命名规范，接口、方法设计，API使用到后面的代码优化都提供了很多的建议，还是可以帮助我们规范不少平时的编码习惯。</p><blockquote class="copyright"><p>本站所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">BY-NC-SA 4.0</a> 许可协议。转载请注明出处！</p></blockquote></main><nav class="pagination"><span class="prev"><a href="/posts/511">EFFECTIVE JAVA 3RD EDITION — 第十章 异常 </a></span><span class="next"><a href="/posts/497">EFFECTIVE JAVA 3RD EDITION — 第八章 方法</a></span></nav><script src="/js/main.js"></script><footer><p class="socials"><a href="https://github.com/lostars" target="_blank"><svg class="fontawesome-icon"><use href="/icons/fontawesome.svg#github"></use></svg> </a><a href="https://open.spotify.com/user/boyizmen" target="_blank"><svg class="fontawesome-icon"><use href="/icons/fontawesome.svg#spotify"></use></svg> </a><a href="https://space.bilibili.com/20516992" target="_blank"><svg class="fontawesome-icon"><use href="/icons/fontawesome.svg#bilibili"></use></svg> </a><input type="hidden" id="emailUser" value="bW9tbw=="> <input type="hidden" id="emailDomain" value="bWluZWkubWU="> <a id="emailLink" href="#" target="_blank"><svg class="fontawesome-icon"><use href="/icons/fontawesome.svg#email"></use></svg></a></p><p>Build with ❤ I abandon here my love</p><p>Copyright &copy; 2025 boyizmen</p></footer></body></html>