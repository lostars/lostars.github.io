<!DOCTYPE html><html><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><link rel="shortcut icon" href="/images/blog/favicon.svg"><meta name="keywords" content=""><meta name="description" content=""><link rel="stylesheet" href="/styles/main.css"><link rel="stylesheet" href="/styles/post.css"><title>JAVA 9 新特性 — MODULE SYSTEM 之 SERVICE - Daydream</title><meta name="generator" content="Hexo 7.3.0"></head><body><header><nav><ul><li><a href="/">Home</a></li><li><a href="/posts/"><span>Posts</span></a></li><li><a href="/categories/"><span>Categories</span></a></li><li><a href="/about"><span>About</span></a></li></ul></nav></header><main><header><h1>JAVA 9 新特性 — MODULE SYSTEM 之 SERVICE</h1><div><time>2018-01-05</time><div class="post-categories"><span class="category-tree"><span class="category-separator">/</span> <a href="/categories/dev/">dev</a></span></div><div class="post-tags"><span class="tag"><span class="category-separator">#</span> <a href="/tags/java/">java</a> </span><span class="tag"><span class="category-separator">#</span> <a href="/tags/jdk9/">jdk9</a></span></div></div></header><p><a href="https://minei.me/archives/297.html">上一篇</a> 介绍了Java 9模块系统的一些基本信息，这一篇介绍模块化服务的实现、加载和使用。</p><p>普通java interface的使用基本是获取实现类或者在实例化接口的时候自己实现。获取实现类这种方式对服务的实现者有一定的入侵，如果在模块化中实现者就必须导出模块，这样项目之间的耦合其实是变强了。而实例化接口时候自己实现又显得太过麻烦。</p><p>Java 9中加载服务服务的方式是使用ServiceLoader来加载，这个其实在java 6中就已经有了，但是在9中重新进行了修改。</p><p>我用一个很简单的demo来具体介绍，定义一个提供获取整数约数的接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">ApproximateGetter</span> &#123;<br> <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 获取约数</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> number</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 返回约数数组</span><br><span class="hljs-comment">     */</span><br>    List&lt;Long&gt; <span class="hljs-title function_">getApproximateNumbers</span><span class="hljs-params">(<span class="hljs-type">long</span> number)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>从java8开始允许接口中定义静态方法，那么我们定义一个获取接口实例的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> ApproximateGetter <span class="hljs-title function_">newInstance</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> ServiceLoader.load(ApproximateGetter.class).findFirst().orElseThrow(() -&amp;gt; <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;no provider available&quot;</span>));<br>&#125;<br></code></pre></td></tr></table></figure><p>事实上java9中的很多接口都是以这种方式来对外提供接口实例的，这样做的好处就是接口的实例模块无需导出（官方也是不推荐导出），服务调用者无需关注服务具体的实现，只需要能够获取到我需要的方法即可。<br>上面的代码中通过ServiceLoader::load方法来加载服务，load方法有多个定义，具体可以查阅文末附上的参考链接。然后从可用的服务提供者中获取第一个返回否则的话抛出异常。</p><p>然后是实现这个接口(定义在另外一个模块中):</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ApproximateEffectiveProvider</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ApproximateGetter</span> &#123;<br> <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">PROVIDER_NAME</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;effective provider&quot;</span>;<br> <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> List&lt;Long&gt; <span class="hljs-title function_">getApproximateNumbers</span><span class="hljs-params">(<span class="hljs-type">long</span> number)</span> &#123;<br>        <span class="hljs-keyword">if</span> (number &lt;= <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        &#125;<br>        <span class="hljs-type">List</span> <span class="hljs-variable">ret</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">long</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; number/<span class="hljs-number">2</span>; i++) &#123;<br>            <span class="hljs-keyword">if</span> (number%i == <span class="hljs-number">0</span>) &#123;<br>                ret.add(i);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>以上操作做完依旧是无法加载到服务的，还有几个非常重要的地方：<br>ServiceLoader::load方式加载服务首先需要在接口定义的模块中用<code>uses</code>关键字声明接口，表明我是作为一个接口暴露出来的，这样load方法才会发现接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">module</span> me.minei.approximate &#123;<br>    <span class="hljs-keyword">exports</span> me.minei.approximate;<br>    uses me.minei.approximate.ApproximateGetter;<br>&#125;<br></code></pre></td></tr></table></figure><p>其实就是在load调用所在的模块必须声明对某个服务的使用，不然模块系统无法找到相应的接口。<br>然后是服务提供者（服务实现）提供服务可以通过两种方式：</p><ul><li>实现者定义在模块中，使用provides…with来提供服务：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">module</span> me.minei.approximate.effective &#123;<br>       <span class="hljs-keyword">requires</span> me.minei.approximate;<br>       provides me.minei.approximate.ApproximateGetter with me.minei.approximate.effective.ApproximateEffectiveProvider;<br>   &#125;<br></code></pre></td></tr></table></figure>多个实现用逗号隔开即可，表明我是通过ApproximateEffectiveProvider来实现ApproximateGetter，系统就会发现该提供者。</li><li>定义在classpath中，这种方式就是非模块化的实现方式，在classpath META-INF&#x2F;services文件夹下配置提供者，文件名称用接口完整包路径命名，内容则是服务实现者的完整包路径，文件必须utf-8编码。</li></ul><p>以上两种方式其实也是部署服务的两种方式，这里主要介绍第一种方式。<br>建立测试类测试:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ApproximateTest</span> &#123;<br> <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br> <br>        System.out.println(ApproximateGetter.availableProvider());<br>        <span class="hljs-type">ApproximateGetter</span> <span class="hljs-variable">getter</span> <span class="hljs-operator">=</span> ApproximateGetter.newInstance();<br>        System.out.println(getter.getApproximateNumbers(<span class="hljs-number">3333</span>));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出: [1, 3, 11, 33, 101, 303, 1111] 这样一个简易的服务提供就完成了。</p><p>服务调用者无需关心具体服务实现，接口只需要将自己暴露（导出）即可，服务提供者对外界都是不可见的。</p><p>服务提供者的实例化方式：</p><ol><li>提供者的无参构造方法。</li><li>提供者提供一个公共静态provider方法，返回接口或者是接口的实现。</li></ol><p>上面两种方式优先第二种方式。</p><p>参考文档：<br><a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/9/docs/api/java/util/ServiceLoader.html">https://docs.oracle.com/javase/9/docs/api/java/util/ServiceLoader.html</a></p><blockquote class="copyright"><p>本站所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">BY-NC-SA 4.0</a> 许可协议。转载请注明出处！</p></blockquote></main><nav class="pagination"><span class="prev"><a href="/posts/302">JAVA 9 新特性 — HTTP2 </a></span><span class="next"><a href="/posts/297">JAVA 9 新特性 — MODULE SYSTEM</a></span></nav><script src="/js/main.js"></script><footer><p class="socials"><a href="https://github.com/lostars" target="_blank"><svg class="fontawesome-icon"><use href="/icons/fontawesome.svg#github"></use></svg> </a><a href="https://open.spotify.com/user/boyizmen" target="_blank"><svg class="fontawesome-icon"><use href="/icons/fontawesome.svg#spotify"></use></svg> </a><a href="https://space.bilibili.com/20516992" target="_blank"><svg class="fontawesome-icon"><use href="/icons/fontawesome.svg#bilibili"></use></svg> </a><input type="hidden" id="emailUser" value="bW9tbw=="> <input type="hidden" id="emailDomain" value="bWluZWkubWU="> <a id="emailLink" href="#" target="_blank"><svg class="fontawesome-icon"><use href="/icons/fontawesome.svg#email"></use></svg></a></p><p>Build with ❤ I abandon here my love</p><p>Copyright &copy; 2025 boyizmen</p></footer></body></html>