<!DOCTYPE html><html><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><link rel="shortcut icon" href="/images/blog/favicon.svg"><meta name="keywords" content=""><meta name="description" content=""><link rel="stylesheet" href="/styles/main.css"><link rel="stylesheet" href="/styles/post.css"><title>EFFECTIVE JAVA 3RD EDITION — 第四章 类与接口（2） - Daydream</title><meta name="generator" content="Hexo 7.3.0"></head><body><header><nav><ul><li><a href="/">Home</a></li><li><a href="/posts/"><span>Posts</span></a></li><li><a href="/categories/"><span>Categories</span></a></li><li><a href="/about"><span>About</span></a></li></ul></nav></header><main><header><h1>EFFECTIVE JAVA 3RD EDITION — 第四章 类与接口（2）</h1><div><time>2018-01-24</time><div class="post-categories"><span class="category-tree"><span class="category-separator">/</span> <a href="/categories/dev/">dev</a></span></div><div class="post-tags"><span class="tag"><span class="category-separator">#</span> <a href="/tags/effective-java-3rd/">effective-java-3rd</a></span></div></div></header><h2 id="Item-21-Design-interfaces-for-posterity"><a href="#Item-21-Design-interfaces-for-posterity" class="headerlink" title="Item 21 : Design interfaces for posterity"></a>Item 21 : Design interfaces for posterity</h2><p><strong>为后续维护、使用者设计好的接口</strong></p><p>Java8之后允许interface提供默认方法，但是如果你要在一个已经发布的接口添加默认方法需要认证考虑带来的影响，所有实现类是否能够提供正确的结果，<br>虽然默认方法实现类都不需要提供实现，但是需要注意虽然编译时候不会报错，但是可能运行后就不是你想要的结果。</p><p>比如Java8里 Collection 接口的removIf方法:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">default</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">removeIf</span><span class="hljs-params">(Predicate&lt;? <span class="hljs-built_in">super</span> E&gt; filter)</span>;<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">removed</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">final</span> Iterator&lt;E&gt; each = iterator();<br>    <span class="hljs-keyword">while</span> (each.hasNext()) &#123;<br>        <span class="hljs-keyword">if</span> (filter.test(each.next())) &#123;<br>            each.remove();<br>            removed = <span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> removed;<br>&#125;<br></code></pre></td></tr></table></figure><p>Collections的内部类SynchronizedCollection就实现了Collection接口，并且重写了removeIf方法，因为这是一个同步集合，需要加锁:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">removeIf</span><span class="hljs-params">(Predicate&lt;? <span class="hljs-built_in">super</span> E&gt; filter)</span> &#123;<br>    <span class="hljs-keyword">synchronized</span> (mutex) &#123;<span class="hljs-keyword">return</span> c.removeIf(filter);&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>试想如果没有重写该方法，多线程调用该方法的时候会出现什么结果？</p><p>所以尽量不要提供默认方法特别是已经存在的接口，除非有特别的需要或者必须，仔细思考对已有实现的影响。</p><h2 id="Item-22-Use-interfaces-only-to-define-types"><a href="#Item-22-Use-interfaces-only-to-define-types" class="headerlink" title="Item 22 : Use interfaces only to define types"></a>Item 22 : Use interfaces only to define types</h2><p><strong>接口只用于定义实现类</strong></p><p>接口（interface）只能用于定义实现类型，而不能用来定义常量，虽然说用起来是非常方便，<br>如果用于定义常量，容易导致api泄露，试想如果不小心实现了一个常量接口，常量值就无法保证不变了。</p><p>比如 java.io.ObjectStreamConstants就是一个反例，但是其常量都用final声明了。<br>如果非要导出常量，推荐下面几种方式:</p><ul><li>如果常量依赖某个接口或者类，把他绑定到某个类导出，比如Integer导出了MAX_VALUE和MIN_VALUE</li><li>使用枚举</li><li>使用一个常量类</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Constant utility class</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PhysicalConstants</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">PhysicalConstants</span><span class="hljs-params">()</span> &#123; &#125; <span class="hljs-comment">// Prevents instantiation</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">double</span> <span class="hljs-variable">AVOGADROS_NUMBER</span> <span class="hljs-operator">=</span> <span class="hljs-number">6.022_140_857e23</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">double</span> <span class="hljs-variable">BOLTZMANN_CONST</span> <span class="hljs-operator">=</span> <span class="hljs-number">1.380_648_52e-23</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">double</span> <span class="hljs-variable">ELECTRON_MASS</span> <span class="hljs-operator">=</span> <span class="hljs-number">9.109_383_56e-31</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>java7之后允许基础类型数据出现下划线，所以对于int,double,float都最好使用下划线来隔开长数字，方便阅读。</p><p>总之接口只用来定义实现类型，而不是常量。</p><h2 id="Item-23-Prefer-class-hierarchies-to-tagged-classes"><a href="#Item-23-Prefer-class-hierarchies-to-tagged-classes" class="headerlink" title="Item 23 : Prefer class hierarchies to tagged classes"></a>Item 23 : Prefer class hierarchies to tagged classes</h2><p><strong>抽象类层次结构</strong></p><p>尽量的去抽象类的层次结构，用一个书中的例子来进行说明：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Tagged class - vastly inferior to a class hierarchy!</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Figure</span> &#123;<br>    <span class="hljs-keyword">enum</span> <span class="hljs-title class_">Shape</span> &#123; RECTANGLE, CIRCLE &#125;;<br>    <span class="hljs-comment">// Tag field - the shape of this figure</span><br>    <span class="hljs-keyword">final</span> Shape shape;<br>    <span class="hljs-comment">// These fields are used only if shape is RECTANGLE</span><br>    <span class="hljs-type">double</span> length;<br>    <span class="hljs-type">double</span> width;<br>    <span class="hljs-comment">// This field is used only if shape is CIRCLE</span><br>    <span class="hljs-type">double</span> radius;<br>    <span class="hljs-comment">// Constructor for circle</span><br>    Figure(<span class="hljs-type">double</span> radius) &#123;<br>        shape = Shape.CIRCLE;<br>        <span class="hljs-built_in">this</span>.radius = radius;<br>    &#125;<br>    <span class="hljs-comment">// Constructor for rectangle</span><br>    Figure(<span class="hljs-type">double</span> length, <span class="hljs-type">double</span> width) &#123;<br>        shape = Shape.RECTANGLE;<br>        <span class="hljs-built_in">this</span>.length = length;<br>        <span class="hljs-built_in">this</span>.width = width;<br>    &#125;<br>    <span class="hljs-type">double</span> <span class="hljs-title function_">area</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">switch</span>(shape) &#123;<br>            <span class="hljs-keyword">case</span> RECTANGLE:<br>                <span class="hljs-keyword">return</span> length * width;<br>            <span class="hljs-keyword">case</span> CIRCLE:<br>                <span class="hljs-keyword">return</span> Math.PI * (radius * radius);<br>            <span class="hljs-keyword">default</span>:<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AssertionError</span>(shape);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面的类就称为标签类（tagged classes）比如一个形状可能有矩形和圆形，他们共有的属性有面积，但是上面的结构有下面不足:</p><ol><li>类结构复杂并且凌乱</li><li>代码可读性差</li><li>内存占用大</li><li>构造方法复杂，多种形状需要多个构造器</li><li>final关键字使用麻烦，需要在构造方法中初始化</li><li>扩展性差，如果你不修改源码根本没办法添加形状，就算修改了也要添加相应的构造方法和switch…case</li><li>根据类名根本无法区分类型，抽象的不够好<br>但Java面向对象的思想提供了一个层级的方式来抽象一个形状，<br>先抽象出形状共有的属性和行为，比如面积，然后扩展这个类，用子类来表示不同的形状，在子类中定义各自的特有属性：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Class hierarchy replacement for a tagged class</span><br><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Figure</span> &#123;<br>    <span class="hljs-keyword">abstract</span> <span class="hljs-type">double</span> <span class="hljs-title function_">area</span><span class="hljs-params">()</span>;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Circle</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Figure</span> &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">double</span> radius;<br>    Circle(<span class="hljs-type">double</span> radius) &#123; <span class="hljs-built_in">this</span>.radius = radius; &#125;<br>    <span class="hljs-meta">@Override</span><br>        <span class="hljs-type">double</span> <span class="hljs-title function_">area</span><span class="hljs-params">()</span> &#123; <span class="hljs-keyword">return</span> Math.PI * (radius * radius);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Rectangle</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Figure</span> &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">double</span> length;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">double</span> width;<br>    Rectangle(<span class="hljs-type">double</span> length, <span class="hljs-type">double</span> width) &#123;<br>        <span class="hljs-built_in">this</span>.length = length;<br>        <span class="hljs-built_in">this</span>.width = width;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-type">double</span> <span class="hljs-title function_">area</span><span class="hljs-params">()</span> &#123; <span class="hljs-keyword">return</span> length * width; &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面的结构就清楚很多，扩展性也强，其实就是强调了Java抽象和封装的概念。</p><h2 id="Item-24-Favor-static-member-classes-over-nonstatic"><a href="#Item-24-Favor-static-member-classes-over-nonstatic" class="headerlink" title="Item 24 : Favor static member classes over nonstatic"></a>Item 24 : Favor static member classes over nonstatic</h2><p><strong>尽量使用静态成员类作为嵌套类</strong></p><p>这一节主要介绍的是四种嵌套类：</p><ul><li>静态成员类(static member classes)<br>static修饰，常用于对外部类没有引用的情况；<br>共有的常用于 helper ，比如私有的常用于内部组件，比如Map的内部对象Entry;</li><li>非静态成员类(nonstatic member classes)<br>通常是要引用外部类或者使用外部类的属性等等才会使用；<br>由于持有对外部类的引用，对象可能无法被gc清理，导致内存泄漏，使用时要注意；</li><li>匿名类(anonymous classes)<br>没有名字，通常都是使用的时候声明并且初始化的；<br>限制很多，不能使用和类名相关的东西比如 instanceOf，不能实现接口，继承类；<br>使用的时候保持代码在10行以内，同时不要影响代码可读性；<br>lambda表达式出现之前，匿名类通常是在做一些一次性操作时候使用，java8之后推荐使用lambda表达式了</li><li>局部类(local classes)<br>是最少使用的，可以在任何声明变量的地方声明，并且遵守相同的作用域，和其他三种有着相同之处:<ol><li>和成员类一样有名字，可以重用;</li><li>和匿名类一样如果要持有外部类的引用不能声明在静态部分，同时也不能包含静态成员，尽量短保持代码可读性;</li></ol></li></ul><h2 id="Item-25-Limit-source-files-to-a-single-top-level-class"><a href="#Item-25-Limit-source-files-to-a-single-top-level-class" class="headerlink" title="Item 25 : Limit source files to a single top-level class"></a>Item 25 : Limit source files to a single top-level class</h2><p><strong>不要在一个文件中定义多个顶级类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Two classes defined in one file. Don&#x27;t ever do this!</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Utensil</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">NAME</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;pan&quot;</span>;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dessert</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">NAME</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;cake&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>比如上面两个类，又在另外一个文件中定义了，那么最终使用的顺序是取决于类传入编译器的先后顺序的，所以尽量避免这种情况的出现。</p><blockquote class="copyright"><p>本站所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">BY-NC-SA 4.0</a> 许可协议。转载请注明出处！</p></blockquote></main><nav class="pagination"><span class="prev"><a href="/posts/340">EFFECTIVE JAVA 3RD EDITION — 第五章 泛型 </a></span><span class="next"><a href="/posts/311">EFFECTIVE JAVA 3RD EDITION — 第四章 类与接口（1）</a></span></nav><script src="/js/main.js"></script><footer><p class="socials"><a href="https://github.com/lostars" target="_blank"><svg class="fontawesome-icon"><use href="/icons/fontawesome.svg#github"></use></svg> </a><a href="https://open.spotify.com/user/boyizmen" target="_blank"><svg class="fontawesome-icon"><use href="/icons/fontawesome.svg#spotify"></use></svg> </a><a href="https://space.bilibili.com/20516992" target="_blank"><svg class="fontawesome-icon"><use href="/icons/fontawesome.svg#bilibili"></use></svg> </a><input type="hidden" id="emailUser" value="bW9tbw=="> <input type="hidden" id="emailDomain" value="bWluZWkubWU="> <a id="emailLink" href="#" target="_blank"><svg class="fontawesome-icon"><use href="/icons/fontawesome.svg#email"></use></svg></a></p><p>Build with ❤ I abandon here my love</p><p>Copyright &copy; 2025 boyizmen</p></footer></body></html>