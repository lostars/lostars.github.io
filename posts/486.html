<!DOCTYPE html><html><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><link rel="shortcut icon" href="/images/blog/favicon.svg"><meta name="keywords" content=""><meta name="description" content=""><link rel="stylesheet" href="/styles/main.css"><link rel="stylesheet" href="/styles/post.css"><title>EFFECTIVE JAVA 3RD EDITION — 第六章 枚举与注解 - Daydream</title><meta name="generator" content="Hexo 7.3.0"></head><body><header><nav><ul><li><a href="/">Home</a></li><li><a href="/posts/"><span>Posts</span></a></li><li><a href="/categories/"><span>Categories</span></a></li><li><a href="/about"><span>About</span></a></li></ul></nav></header><main><header><h1>EFFECTIVE JAVA 3RD EDITION — 第六章 枚举与注解</h1><div><time>2018-11-20</time><div class="post-categories"><span class="category-tree"><span class="category-separator">/</span> <a href="/categories/dev/">dev</a></span></div><div class="post-tags"><span class="tag"><span class="category-separator">#</span> <a href="/tags/effective-java-3rd/">effective-java-3rd</a></span></div></div></header><h2 id="Item-34-Use-enums-instead-of-int-constants"><a href="#Item-34-Use-enums-instead-of-int-constants" class="headerlink" title="Item 34 : Use enums instead of int constants"></a>Item 34 : Use enums instead of int constants</h2><p><strong>使用枚举来代替整型常量</strong></p><p>枚举类型添加以前使用常量的方式来满足使用需要，但是这种方式有很多缺点：<br>无法保证类型安全，并且没有没有表现力（不够优雅）。<br>常量是跟随调用者编译的，如果常量改变了但是调用者没有重新编译那么会出现问题<br>不利于debug，因为你打印出来的都是一些常量。<br>枚举保证了一个编译时类型安全，避免出现枚举滥用错用的情况；同时枚举是单例，并且无法扩展，这也保证了枚举的安全性。<br>同时为了获取常量值，需要定义一系列方法和构造器来供外部访问，同时为了方便debug可以重写 toString 方法。<br>如果有需要，可以让枚举私有、包内私有化或者作为内部类，自然如果需要枚举的共用或者重用可以把他放在顶级包内。</p><h2 id="Item-35-Use-instance-fields-instead-of-ordinals"><a href="#Item-35-Use-instance-fields-instead-of-ordinals" class="headerlink" title="Item 35 :  Use instance fields instead of ordinals"></a>Item 35 : Use instance fields instead of ordinals</h2><p><strong>使用常量属性来代替枚举序号</strong></p><p>避免使用 ordinal 方法，因为枚举的修改都会导致不可预期的序号变换；<br>大部分程序员都不需要这样的一个功能，除非是一个特殊的数据结构比如 Enumset 和 EnumMap 需要遍历枚举的时候。</p><h2 id="Item-36-Use-EnumSet-instead-of-bit-fields"><a href="#Item-36-Use-EnumSet-instead-of-bit-fields" class="headerlink" title="Item 36 : Use EnumSet instead of bit fields"></a>Item 36 : Use EnumSet instead of bit fields</h2><p><strong>使用枚举集合来代替位属性</strong></p><p>比如下面的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Bit field enumeration constants - OBSOLETE! </span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Text</span> &#123;    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">STYLE_BOLD</span>          <span class="hljs-operator">=</span> <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">0</span>;  <span class="hljs-comment">// 1    </span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">STYLE_ITALIC</span>        <span class="hljs-operator">=</span> <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">1</span>;  <span class="hljs-comment">// 2    </span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">STYLE_UNDERLINE</span>     <span class="hljs-operator">=</span> <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">2</span>;  <span class="hljs-comment">// 4    </span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">STYLE_STRIKETHROUGH</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">3</span>;  <span class="hljs-comment">// 8    </span><br>    <span class="hljs-comment">// Parameter is bitwise OR of zero or more STYLE_ constants    </span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">applyStyles</span><span class="hljs-params">(<span class="hljs-type">int</span> styles)</span> &#123; ... &#125; <br>&#125;<br>text.applyStyles(STYLE_BOLD | STYLE_ITALIC);<br></code></pre></td></tr></table></figure><p>这种写法无法直观的修改和检查值，并且也很难去遍历常量，<br>同时你并不能很简单的去检查数据是否溢出，<br>并且一旦确定常量就很难再去作修改，除非修改你的API。</p><p>这个时候使用枚举集合就可以很好的解决这个问题:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// EnumSet - a modern replacement for bit fields </span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Text</span> &#123;    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> <span class="hljs-title class_">Style</span> &#123; BOLD, ITALIC, UNDERLINE, STRIKETHROUGH &#125;    <br>    <span class="hljs-comment">// Any Set could be passed in, but EnumSet is clearly best    </span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">applyStyles</span><span class="hljs-params">(Set&lt;Style&gt; styles)</span> &#123; ... &#125; <br>&#125; <br>text.applyStyles(EnumSet.of(Style.BOLD, Style.ITALIC)); <br></code></pre></td></tr></table></figure><p>很直观并且清晰。<br>注意上面的方法参数是 Set&lt;Style&gt; 而不是 EnumSet，这种时候方法参数最好接收一个接口类而不是他的实现，<br>这样就可以给接口的各种实现提供尽可能多的支持（item 64）<br>总的来说就是需要在集合中使用枚举的时候没有理由用位属性来替代EnumSet，<br>EnumSet唯一缺点就是无法在java9之前创建一个不变的EnumSet，<br>但可以封装 Collections.unmodifiableSet 方法到EnumSet中，不过这样会破坏EnumSet的简洁和性能。</p><h2 id="Item-37-Use-EnumMap-instead-of-ordinal-indexing"><a href="#Item-37-Use-EnumMap-instead-of-ordinal-indexing" class="headerlink" title="Item 37 : Use EnumMap instead of ordinal indexing"></a>Item 37 : Use EnumMap instead of ordinal indexing</h2><p><strong>使用枚举map来代替枚举序号索引</strong></p><p>用书中一个很典型的例子来进一步说明:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Using ordinal() to index array of arrays - DON&#x27;T DO THIS!</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> <span class="hljs-title class_">Phase</span> &#123;<br>    SOLID, LIQUID, GAS;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> <span class="hljs-title class_">Transition</span> &#123;<br>        MELT, FREEZE, BOIL, CONDENSE, SUBLIME, DEPOSIT;<br>        <span class="hljs-comment">// Rows indexed by from-ordinal, cols by to-ordinal</span><br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Transition[][] TRANSITIONS = &#123;<br>            &#123; <span class="hljs-literal">null</span>, MELT, SUBLIME &#125;,<br>            &#123; FREEZE, <span class="hljs-literal">null</span>, BOIL &#125;,<br>            &#123; DEPOSIT, CONDENSE, <span class="hljs-literal">null</span> &#125;<br>        &#125;;<br>        <span class="hljs-comment">// Returns the phase transition from one phase to another</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Transition <span class="hljs-title function_">from</span><span class="hljs-params">(Phase from, Phase to)</span> &#123;<br>            <span class="hljs-keyword">return</span> TRANSITIONS[from.ordinal()][to.ordinal()];<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>用Phase来表示物体的三种状态（固态，液态，气态），同时 Transition 来表示每种状态间转换过程，定义一个二维数组来表示，<br>方法from返回任意两种状态之间的转换过程。</p><p>代码看着是很美好，也很简短。</p><p>首先在二维数组中有null容易导致空指针，如果再加一个状态PLASMA（等离子态），<br>代码修改就比较麻烦，特别是二维数组的维护（顺序错误的话就会返回错误的结果）。</p><p>使用EnumMap来实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> <span class="hljs-title class_">Phase</span> &#123;<br>    SOLID, LIQUID, GAS;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> <span class="hljs-title class_">Transition</span> &#123;<br>        MELT(SOLID, LIQUID), FREEZE(LIQUID, SOLID),<br>        BOIL(LIQUID, GAS), CONDENSE(GAS, LIQUID),<br>        SUBLIME(SOLID, GAS), DEPOSIT(GAS, SOLID);<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Phase from;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Phase to;<br>        Transition(Phase from, Phase to) &#123;<br>            <span class="hljs-built_in">this</span>.from = from;<br>            <span class="hljs-built_in">this</span>.to = to;<br>        &#125;<br>        <span class="hljs-comment">// Initialize the phase transition map</span><br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Map&lt;Phase, Map&lt;Phase, Transition&gt;&gt;<br>            m = Stream.of(values()).collect(groupingBy(t -&gt; t.from,<br>            () -&gt; <span class="hljs-keyword">new</span> <span class="hljs-title class_">EnumMap</span>&lt;&gt;(Phase.class),<br>            toMap(t -&gt; t.to, t -&gt; t,<br>            (x, y) -&gt; y, () -&gt; <span class="hljs-keyword">new</span> <span class="hljs-title class_">EnumMap</span>&lt;&gt;(Phase.class))));<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Transition <span class="hljs-title function_">from</span><span class="hljs-params">(Phase from, Phase to)</span> &#123;<br>            <span class="hljs-keyword">return</span> m.get(from).get(to);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Transition维护的是枚举（转换过程的枚举），列出了所有的转换状态，<br>内部属性m则初始化存储了一个 Map&lt;Phase, EnumMap&lt;Phase, Transition&gt;&gt;，<br>初始化方法调用的是java8的流方法来对m作一个初始化，<br>Phase作为key，value存储的则是该状态转换为其他状态的所有过程。<br>from方法就只需要get返回即可。</p><p>这样写虽然代码量增加了，但是可维护性提升了，如果需要增加一个PLASMA，<br>只需要在PHASE中增加枚举，同时Transition中增加可能的转换过程即可。<br>上面的代码基本不可能给你犯错的机会，除非你连固态到气态的过程都能搞错。</p><p>总的来说不要使用枚举的 ordinal 去作为数组索引，而应该使用EnumMap。</p><h2 id="Item-38-Emulate-extensible-enums-with-interfaces"><a href="#Item-38-Emulate-extensible-enums-with-interfaces" class="headerlink" title="Item 38 :  Emulate extensible enums with interfaces"></a>Item 38 : Emulate extensible enums with interfaces</h2><p><strong>使用接口来增加枚举的拓展性</strong></p><p>这一节主要讲的是枚举的一个扩展性，由于枚举是不能被继承的，导致扩展性很差<br>如果有扩展的需要考虑将扩展点提取到一个接口中，枚举实现该接口，其他的枚举按照需要实现该接口即可。</p><h2 id="Item-39-Prefer-annotations-to-naming-patterns"><a href="#Item-39-Prefer-annotations-to-naming-patterns" class="headerlink" title="Item 39 : Prefer annotations to naming patterns"></a>Item 39 : Prefer annotations to naming patterns</h2><p><strong>使用注解而不是命名模式</strong></p><p>命名模式的缺点（让我想起了JPA）:</p><ol><li>命名容易出现错误；比如junit4之前的版本测试方法必须以test开头，这样很容易出现命名错误（tset），你也只有发现测试方法没有执行才会知道命名错了。</li><li>并不能保证作用在了正确的代码上；比如你创建了一个 TestSafetyMechanisms 类希望Junit3能够测试其内部的所有方法，但事实上并不会执行非test开头的方法。</li><li>不能很好的结合参数和程序代码；比如需要测试在抛出某一个异常的时候通过测试，这时候就需要将异常作为参数传入测试方法，再进行判断。<br>Java8中引入了可重复注解 Repeatable:<br>重复注解只使用在注解字段中存在数组的情况，同时 Repeatable 注解必须指定可以重复的注解，该注解只包含一个数组字段；<br>getAnnotationsByType 方法可以同时获取重复和非重复注解；<br>使用 isAnnotationPresent 方法判断是否有某个注解时需要格外注意：<br>如果参数传入实际写在代码中的注解，则会忽略只包含一个数组字段的注解（真正意义上重复的注解），<br>如果参数传入上面后者，则会忽略上面前者；<br>所以使用该方法时需要判断两个注解是否存在。<br>重复注解的出现旨在提升代码可读性，看需求使用。</li></ol><p>如果代码需要调用者传入参数到源码中就使用注解而不是去使用命名模式。<br>虽然大部分的编码都不需要定义注解，但是java内置的一些注解还是应该使用的（比如 Override），<br>这些注解已经成立了标准使用之前还是需要多看看。</p><h2 id="Item-40-Consistently-use-the-Override-annotation"><a href="#Item-40-Consistently-use-the-Override-annotation" class="headerlink" title="Item 40 : Consistently use the Override annotation"></a>Item 40 : Consistently use the Override annotation</h2><p><strong>坚持使用Override注解</strong></p><p>如果不使用 Override 注解，比如 equals 方法，就会出现一些意外情况，使用注解同时会帮助你检查是否正确的覆盖了父类的方法。<br>大部分IDE都会在你实现接口或者覆盖父类方法的同时自动加上注解。<br>当然如果覆盖了一个抽象方法，这个时候你就没必要添加 Override 注解了。</p><h2 id="Item-41-Use-marker-interfaces-to-define-types"><a href="#Item-41-Use-marker-interfaces-to-define-types" class="headerlink" title="Item 41 : Use marker interfaces to define types"></a>Item 41 : Use marker interfaces to define types</h2><p><strong>使用标记接口来定义类型</strong></p><p>标记接口定义：没有声明任何方法的接口，比如Java api中的Serializable，表示某个实现该接口的对象可以被序列化。<br>标记注解定义类似，两者都只是作一个标记，表明某个功能或用途。</p><p>标记接口相对于标记注解的好处：</p><ol><li>标记接口定义了一个可以被标记类所实现的类型（因为是接口），标记注解不能；</li><li>标记接口可以被更精确的定位；如果使用的是一个标记注解（ElementType.TYPE），它可以被使用到任何可以使用的地方，<br>而标记接口则可以只继承（只让它适用）该接口，让所有标记类都实现该接口，从而达到可适用的目的。比如 Set 接口则是一个限制的标记接口，它只适用于 Collection 的子类。<br>而标记注解相对标记接口的优点则是：可在一个注解集成的框架中使用。</li></ol><p>那么如何正确的使用它们？<br>如果标记是作用于元素（属性）的话肯定是使用注解，<br>而作用于类或者是接口，并且会写一些只接收标记对象方法的话则使用标记接口，这样就会让你传入接口作为参数，同时在编译期间做了类型检查。</p><p>当你定义的注解目标是 ElementType.TYPE 的时候，则需要思考使用哪个才是更为合适。</p><hr><p>这一章介绍的两个主要内容：<br>枚举，需要谨慎使用ordinal方法，多考虑使用EnumSet EnumMap；<br>注解，简单介绍使用方式；</p><blockquote class="copyright"><p>本站所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">BY-NC-SA 4.0</a> 许可协议。转载请注明出处！</p></blockquote></main><nav class="pagination"><span class="prev"><a href="/posts/491">EFFECTIVE JAVA 3RD EDITION — 第七章 LAMBDA表达式与流 </a></span><span class="next"><a href="/posts/422">JAVA三目运算中隐藏的自动拆装箱</a></span></nav><script src="/js/main.js"></script><footer><p class="socials"><a href="https://github.com/lostars" target="_blank"><svg class="fontawesome-icon"><use href="/icons/fontawesome.svg#github"></use></svg> </a><a href="https://open.spotify.com/user/boyizmen" target="_blank"><svg class="fontawesome-icon"><use href="/icons/fontawesome.svg#spotify"></use></svg> </a><a href="https://space.bilibili.com/20516992" target="_blank"><svg class="fontawesome-icon"><use href="/icons/fontawesome.svg#bilibili"></use></svg> </a><input type="hidden" id="emailUser" value="bW9tbw=="> <input type="hidden" id="emailDomain" value="bWluZWkubWU="> <a id="emailLink" href="#" target="_blank"><svg class="fontawesome-icon"><use href="/icons/fontawesome.svg#email"></use></svg></a></p><p>Build with ❤ I abandon here my love</p><p>Copyright &copy; 2025 boyizmen</p></footer></body></html>