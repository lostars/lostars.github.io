<!DOCTYPE html><html><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><link rel="shortcut icon" href="/images/blog/favicon.svg"><meta name="keywords" content=""><meta name="description" content=""><link rel="stylesheet" href="/styles/main.css"><link rel="stylesheet" href="/styles/post.css"><title>EFFECTIVE JAVA 3RD EDITION — 第四章 类与接口（1） - Daydream</title><meta name="generator" content="Hexo 7.3.0"></head><body><header><nav><ul><li><a href="/">Home</a></li><li><a href="/posts/"><span>Posts</span></a></li><li><a href="/categories/"><span>Categories</span></a></li><li><a href="/about"><span>About</span></a></li></ul></nav></header><main><header><h1>EFFECTIVE JAVA 3RD EDITION — 第四章 类与接口（1）</h1><div><time>2018-01-16</time><div class="post-categories"><span class="category-tree"><span class="category-separator">/</span> <a href="/categories/dev/">dev</a></span></div><div class="post-tags"><span class="tag"><span class="category-separator">#</span> <a href="/tags/effective-java-3rd/">effective-java-3rd</a></span></div></div></header><h2 id="Item-15-Minimize-the-accessibility-of-classes-and-members"><a href="#Item-15-Minimize-the-accessibility-of-classes-and-members" class="headerlink" title="Item 15 : Minimize the accessibility of classes and members"></a>Item 15 : Minimize the accessibility of classes and members</h2><p><strong>最小化类与成员的访问级别</strong></p><p>隐藏实现信息或者成员信息有多个好处：</p><ul><li>有助于组件之间解耦</li><li>提升开发效率，多组件之间可以并行开发</li><li>减少维护成本，因为组件调试或者替换不影响其他部分</li><li>增加重用率，因为组件之间都是解耦的</li><li>减少开发大型系统的风险<br>用尽可能低的访问级别去定义软件功能，当你需要访问包内其他类的时候才将那个类从私有改为 package-private ，但是如果经常这样考虑设计一个解耦出来的类。</li></ul><p>私有成员和包私有成员都是类实现的一部分，通常不会影响其导出的api，如果类实现了 Serializable 可能导致这些字段”泄露”到api中。</p><p>一个类的保护成员通常是代表了一个类实现细节，所以相对用的较少。</p><p>如果一个子类重写了父类的一个方法，那么这个方法的访问级别不能超过父类，就确保了只要父类能够使用该方法的地方子类都能使用，<br>特别的，一个类实现了一个接口那么所有的实现方法都应该是 public。<br>有时候为了测试可能会让成员包内私有，但不接受更高的访问级别。</p><p>公共类的实例字段很少是公共的，也就是说公共的可改变属性是线程不安全的，因为是公共的无法在类内部进行控制。<br>尽管这个字段有可能是 final 并且是不变对象的引用，只要公共了就失去了可以随时替换它的灵活性。</p><p>长度非0的数组永远都是可变的，所以静态 final 数组字段或者返回这么一个字段都是错误的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Thing[] VALUES = &#123; ... &#125;<br></code></pre></td></tr></table></figure><p>可以这样修改：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Thing[] PRIVATE_VALUES = &#123; ... &#125;;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">List</span> <span class="hljs-variable">VALUES</span> <span class="hljs-operator">=</span><br>Collections.unmodifiableList(Arrays.asList(PRIVATE_VALUES));<br></code></pre></td></tr></table></figure><p>或者</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Thing[] PRIVATE_VALUES = &#123; ... &#125;;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Thing[] values() &#123;<br>    <span class="hljs-keyword">return</span> PRIVATE_VALUES.clone();<br>&#125;<br></code></pre></td></tr></table></figure><p>Java 9 中新增的模块系统隐含了新的访问级别：</p><ul><li>未导出包都是模块内可访问，外部模块无法访问</li><li>模块系统提供了一个共享包的方式来使包内所有类可访问而不用每一个去控制访问级别</li><li>但如果你把模块化的jar包放在非 module path 下的话会被当做普通jar包，模块之间的访问级别就不存在了</li><li>模块的编写需要你组合包，声明依赖，重新组织包结构来方便模块之间的访问和非模块结构的访问</li></ul><p>总的来说尽量减小程序的访问级别，设计一个最小化的公共api，公共类尽量不要包含公共字段，保证静态 final 字段不变。</p><h2 id="Item-16-use-accessor-methods-not-public-fields-in-public-classes"><a href="#Item-16-use-accessor-methods-not-public-fields-in-public-classes" class="headerlink" title="Item 16 : use accessor methods not public fields in public classes"></a>Item 16 : use accessor methods not public fields in public classes</h2><p><strong>为公共类提供内部属性访问方法而不是让内部属性成为公共的</strong></p><p>公共类属性最好不要公共，而是提供方法访问，比如 get 方法。如果一个类是包内私有或者是内部类，暴露其内部属性也无妨</p><p>但Java 中Dimension类却暴露了其内部属性，这是一个反面例子，同时（在 item 67中提到）造成了严重的性能影响。</p><p>虽然不推荐暴露类内部属性，但如果属性是不变 final 的，暴露也是可以的，比如下面：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Time</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">HOURS_PER_DAY</span> <span class="hljs-operator">=</span> <span class="hljs-number">24</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">MINUTES_PER_HOUR</span> <span class="hljs-operator">=</span> <span class="hljs-number">60</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> hour;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> minute;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Time</span><span class="hljs-params">(<span class="hljs-type">int</span> hour, <span class="hljs-type">int</span> minute)</span> &#123;<br>        <span class="hljs-keyword">if</span> (hour &lt; <span class="hljs-number">0</span> || hour &gt;= HOURS_PER_DAY)<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;Hour: &quot;</span> + hour);<br>        <span class="hljs-keyword">if</span> (minute &lt; <span class="hljs-number">0</span> || minute &gt;= MINUTES_PER_HOUR)<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;Min: &quot;</span> + minute);<br>        <span class="hljs-built_in">this</span>.hour = hour;<br>        <span class="hljs-built_in">this</span>.minute = minute;<br>    &#125;<br>    ... <span class="hljs-comment">// Remainder omitted</span><br>&#125;<br></code></pre></td></tr></table></figure><p>简言之类不应该暴露可变字段，暴露不变字段依旧是待商榷的，有时需要包私有或者私有类暴露其属性。</p><h2 id="Item-17-Minimize-mutability"><a href="#Item-17-Minimize-mutability" class="headerlink" title="Item 17 : Minimize mutability"></a>Item 17 : Minimize mutability</h2><p><strong>最小化类的可变性</strong></p><p>不可变类设计和使用更加简单，更少出错和安全。设计一个不可变类需要遵循下面几点：</p><ol><li>不提供方法改变类的状态</li><li>保证类不可继承，类声明 final 或者构造方法私有然后提供一个静态工厂方法返回实例，避免无意或者恶意的继承造成父类状态的改变</li><li>使所有字段 final，同时保证新建实例的引用可以跨线程而无需同步</li><li>使所有字段私有</li><li>确保独占可变组件<br>不变对象是线程安全的，不需要同步，可以被自由共享，应该尽可能的被重用。</li></ol><p>可以提供一个工厂方法来缓存被频繁请求的实例，避免重复创建实例，比如所有的包装类都这样做，这样可以让调用这复用对象而不是反复创建，减少内存占用和gc开销。<br>提供工厂方法比提供公共的构造器有更多的灵活性去后续可以轻松添加缓存。</p><p>可以共享不变对象，不变对象也可以共享其内部属性，比如 BigInteger 类 negate 方法每次都是使用 final 属性 signum 和 mag 来构造新的实例。</p><p>不变对象为其他类提供了构建模块，比如在你使用一个复杂的类的时候如果这个类的组件都是不可变的那就会轻松很多。</p><p>不变类创建之后状态不再改变，所以不存在一个临时的状态。</p><p>不变对象最主要的缺陷在于对于不同的值需要单独的对象，通常这些类的创建都是十分消耗巨大，特别是当他很大的时候<br>比如你有一个百万位的 BigInteger 你想修改他的低位：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">BigInteger</span> <span class="hljs-variable">moby</span> <span class="hljs-operator">=</span> ...;<br>moby = moby.flipBit(<span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure><p>flipBit 方法会创建一个新的同样长度的实例，只有一位不同，这个操作会根据 BigInteger 的长度而成比例的消耗时间和空间，BitSet 类似不过是可变的。</p><p>如果你执行多步操作，每步都生成新对象，但最后除了结果其他对象全部丢弃，这会造成性能问题。可以作下面的处理：</p><ol><li>从多步操作中提取出基本操作，这样就不需要每一步都创建新对象</li><li>如果能够准确的预估出调用者什么时候能够进行这些复杂操作，提供一个包内私有同胞类来处理，比如String 和 StringBuilder<br>上面第三点提到属性 final ，但其实可以更宽松一点来进行性能的提升，比如用一个非 final 字段来缓存一个需要大量计算的值。</li></ol><p>如果不变类实现了 Serializable 接口，最好提供明确的 readObject 或者 readResolve 方法，或者使用 ObjectOutputStream.writeUnshared 和 ObjectInputStream.readUnshared，<br>否则的话攻击者可以创建一个可变的实例，这在 item 88 中有详细介绍。</p><p>总的来说，不要给每一个 get 方法提供 set 方法，类应该保持不变性除非有足够的理由让他们可变，不变类最大的不足就是某些环境下潜在的性能缺陷；<br>应该尽量使“小”的类不变，考虑是否写一个“大”类；<br>为不变类提供同胞类来满足性能需求；<br>如果一个类无法做到不变，那么尽可能的缩小他的变数；<br>声明所有的字段 final ，除非有充分理由不这么做；<br>构造器应该使用所有不变类的不变字段来实例化，不要提供除构造器和静态工厂方法以外的方法初始化对象；<br>不要提供一个重新初始化对象的方法来提高重用，这样做可能会提高性能但会大大增加程序复杂度，CountDownLatch 类是一个很好的不变类的例子。</p><h2 id="Item-18-Favor-composition-over-inheritance"><a href="#Item-18-Favor-composition-over-inheritance" class="headerlink" title="Item 18 : Favor composition over inheritance"></a>Item 18 : Favor composition over inheritance</h2><p><strong>优先构成而不是继承</strong></p><p>本书说的继承是指实现继承（一个类扩展另一个类），本节不包含接口实现或者说接口扩展另一个接口。</p><p>继承只在包内进行，跨包的继承是危险的，只针对确实需要继承的类（文档说明了需要），或者说子类确实“是”父类，扩展父类的功能或者属性等等；<br>继承同时也破坏了封装；<br>子类不可控的可以获得新的方法然后直接重写，如果父类扩展了的话；<br>可以用 extend 来避免方法重写带来的上面问题，但是如果如果父类和子类的方法一样，那也成了重写，因为你无法避免父类的方法添加不和子类重复。</p><p>java中有不少类其实是违反了上面的规则，比如 Stack 不应该继承 Vector ，Properties 不应该继承 Hashtable等等，他们都不是自己的父类类型。</p><p>解决上面问题的方法就是用构成来代替继承，就是说给你的类添加一个私有对象引用，让已有的类成为另一个类的一个组件，<br>通常使用类和引用类之间还有一个转发类，利于重用，比如下面的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Wrapper class - uses composition in place of inheritance</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">InstrumentedSet</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ForwardingSet</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">addCount</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">InstrumentedSet</span><span class="hljs-params">(Set s)</span> &#123;<br>        <span class="hljs-built_in">super</span>(s);<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">add</span><span class="hljs-params">(E e)</span> &#123;<br>        addCount++;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>.add(e);<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">addAll</span><span class="hljs-params">(Collection&lt;? extends E&gt; c)</span> &#123;<br>        addCount += c.size();<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>.addAll(c);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getAddCount</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> addCount;<br>    &#125;<br>&#125;<br><span class="hljs-comment">// Reusable forwarding class</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ForwardingSet</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Set</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Set s;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ForwardingSet</span><span class="hljs-params">(Set s)</span> &#123; <span class="hljs-built_in">this</span>.s = s; &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">clear</span><span class="hljs-params">()</span> &#123; s.clear(); &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">contains</span><span class="hljs-params">(Object o)</span> &#123; <span class="hljs-keyword">return</span> s.contains(o); &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isEmpty</span><span class="hljs-params">()</span> &#123; <span class="hljs-keyword">return</span> s.isEmpty(); &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">size</span><span class="hljs-params">()</span> &#123; <span class="hljs-keyword">return</span> s.size(); &#125;<br>    <span class="hljs-keyword">public</span> Iterator <span class="hljs-title function_">iterator</span><span class="hljs-params">()</span> &#123; <span class="hljs-keyword">return</span> s.iterator(); &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">add</span><span class="hljs-params">(E e)</span> &#123; <span class="hljs-keyword">return</span> s.add(e); &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">remove</span><span class="hljs-params">(Object o)</span> &#123; <span class="hljs-keyword">return</span> s.remove(o); &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">containsAll</span><span class="hljs-params">(Collection&lt;?&gt; c)</span><br>    &#123; <span class="hljs-keyword">return</span> s.containsAll(c); &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">addAll</span><span class="hljs-params">(Collection&lt;? extends E&gt; c)</span><br>    &#123; <span class="hljs-keyword">return</span> s.addAll(c); &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">removeAll</span><span class="hljs-params">(Collection&lt;?&gt; c)</span><br>    &#123; <span class="hljs-keyword">return</span> s.removeAll(c); &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">retainAll</span><span class="hljs-params">(Collection&lt;?&gt; c)</span><br>    &#123; <span class="hljs-keyword">return</span> s.retainAll(c); &#125;<br>    <span class="hljs-keyword">public</span> Object[] toArray() &#123; <span class="hljs-keyword">return</span> s.toArray(); &#125;<br>    <span class="hljs-keyword">public</span>  T[] toArray(T[] a) &#123; <span class="hljs-keyword">return</span> s.toArray(a); &#125;<br>    <span class="hljs-meta">@Override</span> <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">equals</span><span class="hljs-params">(Object o)</span><br>    &#123; <span class="hljs-keyword">return</span> s.equals(o); &#125;<br>    <span class="hljs-meta">@Override</span> <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hashCode</span><span class="hljs-params">()</span> &#123; <span class="hljs-keyword">return</span> s.hashCode(); &#125;<br>    <span class="hljs-meta">@Override</span> <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123; <span class="hljs-keyword">return</span> s.toString(); &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面第一个类被叫做包装类（wrapper class），注意与基本类型包装类区分开，因为他包含了另一个 Set，<br>第二个类里面的方法叫做转发方法，无需担心包装类的内存占用或者是转发类的性能问题。</p><p>缺点：</p><ul><li>不适合那些回调框架，因为包装类是不知道自己的包装器是谁，只能返回自身的一个引用，并且这个引用还没有包装器</li><li>转发类编写略显枯燥，不过这个类是可以重用的</li></ul><h2 id="Item-19-Design-and-document-for-inheritance-or-else-prohibit-it"><a href="#Item-19-Design-and-document-for-inheritance-or-else-prohibit-it" class="headerlink" title="Item 19 : Design and document for inheritance or else prohibit it"></a>Item 19 : Design and document for inheritance or else prohibit it</h2><p><strong>继承类必须精心设计文档清楚否则就不要让他可继承</strong></p><p>可继承类的文档需要清楚的写明每个可重写方法的调用地方，结果和影响。</p><p>继承类通过保护方法或者保护字段向其子类提供访问内部的方式。</p><p>唯一一个测试可继承类的方法是在发布前写子类测试，并且最好由多个不同的人去测试而不是仅仅作者本人。</p><p>可继承类构造器不能直接或者间接用可重写方法，如果实现了 Cloneable 和 Serializable 接口，和构造器一样 clone 和 readObject 方法不能直接或者间接调用可重写方法。</p><p>实现了 Serializable 接口，其 readResolve 和 writeReplace 方法必须 protected 而不是私有。</p><p>如果一个类本身设计就是不用于安全的继承，文档也没写明需要继承那么就禁用继承：</p><ol><li>构造器私有</li><li>声明 final<br>总的来说设计一个可继承类是十分费力的，文档需要写明每一个内部调用，每一个可重写方法需要注意的地方，一旦发布，那么就要背着这个坑了，<br>同时为了使用者设计出高效的子类可能需要父类暴露部分内部字段等等，可以通过提供保护方法或者字段来实现。</li></ol><h2 id="Item-20-Prefer-interfaces-to-abstract-classes"><a href="#Item-20-Prefer-interfaces-to-abstract-classes" class="headerlink" title="Item 20 : Prefer interfaces to abstract classes"></a>Item 20 : Prefer interfaces to abstract classes</h2><p><strong>优先考虑将接口抽象为抽象接口</strong></p><p>Java有两种方式来定义一个可以多实现的类：接口和抽象类。</p><p>Java8中允许default方法之后可以在接口中直接定义接口实例化方法，比如item 1提到的instance方法。</p><p>已经存在的类可以很轻松的实现一个新接口，但是抽象类不行，因为一个类不能多继承，除非继承的两个类是父子关系。</p><p>接口非常适合定义混合功能或者说方法，因为接口更像一个方法集合，提供各种可选方法和功能，但是抽象类不行也是因为上面的原因。</p><p>接口可以构建非层次结构的框架，比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Singer</span> &#123;<br>    AudioClip <span class="hljs-title function_">sing</span><span class="hljs-params">(Song s)</span>;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Songwriter</span> &#123;<br>    Song <span class="hljs-title function_">compose</span><span class="hljs-params">(<span class="hljs-type">int</span> chartPosition)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>但是一个歌手很可能既能唱歌也能写歌，所以：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">SingerSongwriter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Singer</span>, Songwriter &#123;<br>    AudioClip <span class="hljs-title function_">strum</span><span class="hljs-params">()</span>;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">actSensitive</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>你有可能不需要上面的这种结构，但是如果对每一种组合类型都进行支持，如果有n个属性，那么就会有2的n次方中组合，这相比上面的结构复杂很多，<br>同时多种组合会导致类方法过多难以区分，也违背了接口定义的原则。</p><p>接口通过包装类（item18）对功能进行了增加和安全加固，但是如果使用抽象类的话子类就可以通过继承无限制的扩展抽象类方法。</p><p>抽象接口提供了接口所有方法实现但同时不强制继承抽象类。</p><p>普通接口实现可以将接口方法转发给内部一个继承抽象接口的内部类，被称作 simulated multiple inheritance 模拟多重继承。</p><p>编写一个抽象接口十分简单：</p><ul><li>看文档了解接口哪些基本方法会被实现者实现，那些方法就是抽象接口中的抽象方法</li><li>在接口上提供可以在上面的基本方法上实现的所有方法的 default 方法，可能不提供对象基本方法</li><li>如果上面的方法覆盖了接口，那么抽象接口就完成了并且不需要实现，否则的话写一个类实现接口中剩下的方法<br>比如：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AbstractMapEntry</span>&lt;K,V&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Map</span>.Entry&lt;K,V&gt; &#123;<br>       <span class="hljs-comment">// Entries in a modifiable map must override this method</span><br>       <span class="hljs-meta">@Override</span><br>       <span class="hljs-keyword">public</span> V <span class="hljs-title function_">setValue</span><span class="hljs-params">(V value)</span> &#123;<br>           <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UnsupportedOperationException</span>();<br>       &#125;<br>       <span class="hljs-comment">// Implements the general contract of Map.Entry.equals</span><br>       <span class="hljs-meta">@Override</span><br>       <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">equals</span><span class="hljs-params">(Object o)</span> &#123;<br>           <span class="hljs-keyword">if</span> (o == <span class="hljs-built_in">this</span>)<br>               <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>           <span class="hljs-keyword">if</span> (!(o <span class="hljs-keyword">instanceof</span> Map.Entry))<br>               <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>           Map.Entry&lt;!--?,?--&gt; e = (Map.Entry) o;<br>           <span class="hljs-keyword">return</span> Objects.equals(e.getKey(), getKey()) &amp;&amp; Objects.equals(e.getValue(), getValue());<br>       &#125;<br>       <span class="hljs-comment">// Implements the general contract of Map.Entry.hashCode</span><br>       <span class="hljs-meta">@Override</span><br>       <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hashCode</span><span class="hljs-params">()</span> &#123;<br>           <span class="hljs-keyword">return</span> Objects.hashCode(getKey()) ^ Objects.hashCode(getValue());<br>       &#125;<br>       <span class="hljs-meta">@Override</span><br>       <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>           <span class="hljs-keyword">return</span> getKey() + <span class="hljs-string">&quot;=&quot;</span> + getValue();<br>       &#125;<br>   &#125;<br></code></pre></td></tr></table></figure>抽象接口的编写也需要遵循item19提到的规则。</li></ul><p>总的来说接口通常是一个需要多实现最好的方式，如果有导出接口的需要定义一个抽象接口，对接口的限制通常也采用抽象接口来实现。</p><blockquote class="copyright"><p>本站所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">BY-NC-SA 4.0</a> 许可协议。转载请注明出处！</p></blockquote></main><nav class="pagination"><span class="prev"><a href="/posts/319">EFFECTIVE JAVA 3RD EDITION — 第四章 类与接口（2） </a></span><span class="next"><a href="/posts/305">EFFECTIVE JAVA 3RD EDITION — 第三章 对象基本方法</a></span></nav><script src="/js/main.js"></script><footer><p class="socials"><a href="https://github.com/lostars" target="_blank"><svg class="fontawesome-icon"><use href="/icons/fontawesome.svg#github"></use></svg> </a><a href="https://open.spotify.com/user/boyizmen" target="_blank"><svg class="fontawesome-icon"><use href="/icons/fontawesome.svg#spotify"></use></svg> </a><a href="https://space.bilibili.com/20516992" target="_blank"><svg class="fontawesome-icon"><use href="/icons/fontawesome.svg#bilibili"></use></svg> </a><input type="hidden" id="emailUser" value="bW9tbw=="> <input type="hidden" id="emailDomain" value="bWluZWkubWU="> <a id="emailLink" href="#" target="_blank"><svg class="fontawesome-icon"><use href="/icons/fontawesome.svg#email"></use></svg></a></p><p>Build with ❤ I abandon here my love</p><p>Copyright &copy; 2025 boyizmen</p></footer></body></html>