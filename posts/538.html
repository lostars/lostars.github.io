<!DOCTYPE html><html><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><link rel="shortcut icon" href="/images/blog/favicon.svg"><meta name="keywords" content=""><meta name="description" content=""><link rel="stylesheet" href="/styles/main.css"><link rel="stylesheet" href="/styles/post.css"><title>EFFECTIVE JAVA 3RD EDITION — 第十一章 并发编程 - Daydream</title><meta name="generator" content="Hexo 7.3.0"></head><body><header><nav><ul><li><a href="/">Home</a></li><li><a href="/posts/"><span>Posts</span></a></li><li><a href="/categories/"><span>Categories</span></a></li><li><a href="/about"><span>About</span></a></li></ul></nav></header><main><header><h1>EFFECTIVE JAVA 3RD EDITION — 第十一章 并发编程</h1><div><time>2019-08-22</time><div class="post-categories"><span class="category-tree"><span class="category-separator">/</span> <a href="/categories/dev/">dev</a></span></div><div class="post-tags"><span class="tag"><span class="category-separator">#</span> <a href="/tags/effective-java-3rd/">effective-java-3rd</a></span></div></div></header><h2 id="Item-78-Synchronize-access-to-shared-mutable-data"><a href="#Item-78-Synchronize-access-to-shared-mutable-data" class="headerlink" title="Item 78 : Synchronize access to shared mutable data"></a>Item 78 : Synchronize access to shared mutable data</h2><p><strong>共享可变数据需要同步</strong></p><p><code>synchronized</code>关键字可以保证同时只有一个线程可以执行或者阻塞该方法；<br>除了long和double之外，Java语言特性都能保证对变量的读写操作是原子的；<br>long和double读写要实现原子操作，可以<code>volatile</code>关键字来实现，或者使用<code>AtomicLong</code>来实现；</p><p>线程之间的可靠通信和互斥是需要同步的，这是Java内存模型规范的一部分，规定了一个线程所作的修改合适以及如何对其他线程可见。</p><p>从线程中停止另一个线程Java提供了Thread.stop方法，但是不要使用这个方法，因为其本身是不安全的，正确的方法是使用一个boolean值作为标志来进行操作，比如下面的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Broken! - How long would you expect this program to run? </span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StopThread</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> stopRequest;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">backgroundThread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">I</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">while</span> (!stopRequested)<br>                i++;<br>        &#125;);<br>        backgroundThread.start();<br>        TimeUnit.SECONDS.sleep(<span class="hljs-number">1</span>);<br>        stopRequested = <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面代码预期是在程序启动1s之后停止后台线程，但事实上程序和后台线程都不会停止，因为缺少了同步操作，下面的代码是其中一中同步方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Properly synchronized cooperative thread termination</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StopThread</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> stopRequest;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">requestStop</span><span class="hljs-params">()</span> &#123;<br>        stopRequest = <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">stopRequested</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> stopRequested;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">backgroundThread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">I</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">while</span> (!stopRequested)<br>                i++;<br>        &#125;);<br>        backgroundThread.start();<br>        TimeUnit.SECONDS.sleep(<span class="hljs-number">1</span>);<br>        requestStop();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果不能保证读写都同步，那么同步并不能正常的工作；或者可以使用<code>volatile</code>关键字来修饰变量，保证变量的修改能够被其他线程及时读取到：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Cooperative thread termination with a volatile field </span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StopThread</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">boolean</span> stopRequest;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">backgroundThread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">I</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">while</span> (!stopRequested)<br>                i++;<br>        &#125;);<br>        backgroundThread.start();<br>        TimeUnit.SECONDS.sleep(<span class="hljs-number">1</span>);<br>        stopRequested = <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在使用<code>volatile</code>关键字的时候要小心，他只能保证线程间的变量修改可见性，并不能保证原子性；<br>最好的就是不要在线程间共享可变资源，也就是说在单线程中处理可变资源。<br>当多线程共享资源的时候需要对资源的读写操作进行同步，通常没有进行同步造成的bug都非常难以debug和排查，<br><code>volatile</code>关键字能够保证多线程间的数据可见性，但是他不保证原子性，使用的时候需要多加注意。</p><h2 id="Item-79-Avoid-excessive-synchronization"><a href="#Item-79-Avoid-excessive-synchronization" class="headerlink" title="Item 79 : Avoid excessive synchronization"></a>Item 79 : Avoid excessive synchronization</h2><p><strong>避免过多同步</strong></p><p>不要在同步块中设计可以被覆盖的方法，或者由客户端提供的一个方法，因为无法控制该方法被覆盖后的操作；作为规范，不要在同步块中做过多的操作，如果非要在同步块中进行耗时的操作，尽量在不破坏原有逻辑的情况下将耗时操作放到同步块之外。</p><p>在多核的情况下，消耗时间不是cpu获取锁的时间，而是对资源的竞争和保证每个核心享有相同的内存对象（对象同步）；过度的同步同时也会限制jvm优化执行代码的能力；当不知道是否需要对类进行同步时，那就不要做任何同步，并且做出说明该类时线程不安全的。</p><p>总的来说，为了避免死锁和数据中断，尽量不要在同步块中调用耗时的方法，同时应该将这种耗时逻辑放到同步块之外，保证同步块中的逻辑最小化；同时在设计一个不变的类的时候考虑是否需要实现同步；多核情况下更重的是不要过度的同步。</p><h2 id="Item-80-Prefer-executors-tasks-and-streams-to-threads"><a href="#Item-80-Prefer-executors-tasks-and-streams-to-threads" class="headerlink" title="Item 80 : Prefer executors, tasks, and streams to threads"></a>Item 80 : Prefer executors, tasks, and streams to threads</h2><p><strong>在线程中多使用Java提供的线程池，任务工具类和流操作</strong></p><h2 id="Item-81：Prefer-concurrency-utilities-to-wait-and-notify"><a href="#Item-81：Prefer-concurrency-utilities-to-wait-and-notify" class="headerlink" title="Item 81：Prefer concurrency utilities to wait and notify"></a>Item 81：Prefer concurrency utilities to wait and notify</h2><p><strong>使用并发包工具来处理wait notify操作</strong></p><p>直接使用wait和notify难度较高，可以考虑使用更高级的并发包来处理；并发包中的集合有很高的性能，对其加锁会减慢程序速度，同时在并发集合中排除并发操作时不可能的；</p><p>在代码内部计时中通常使用<code>System.nanoTime</code>而不是<code>System.currentTimeMills</code>，前者更加精确，并且不会被系统时钟所影响；精确的性能测试非常麻烦，通常使用一些框架来进行，比如JMH。wait操作总是需要在循环中执行，循环在等待前后起了条件检测的作用。</p><p>条件没有满足但是线程却被唤醒了有下面几种情况：</p><ul><li>另一个线程可以获得锁，并且在线程调用notify和等待线程唤醒的时候改变了保护状态；</li><li>另一个线程没有达到条件却意外或者恶意的执行了notify方法；</li><li>通知线程在等待唤醒中过于“慷慨”，比如尽管只有一些等待线程满足条件通知线程也会执行notifyAll方法；</li><li>等待线程缺少通知的条件下小几率会被唤醒，被称作伪唤醒；<br>通常使用notifyAll来代替notify，虽然前者会唤醒所有线程，但是都会去检测是否符合条件，如果不符合则会继续等待；同时，使用notifyAll可以避免一些不相关对象偶然或者恶意的等待，否则的话这种等待可能忽略一些关键信息导致一直等待。</li></ul><p>总的来说在循环中使用nofity和wait，并且通常使用nofityAll来唤醒线程，如果使用notify的话就需要格外的关注是否能够一定被唤醒。</p><h2 id="Item-82-：Document-thread-safety"><a href="#Item-82-：Document-thread-safety" class="headerlink" title="Item 82 ：Document thread safety"></a>Item 82 ：Document thread safety</h2><p><strong>文档标注清楚线程是否安全</strong></p><p>为了安全的并发使用，一个类必须清楚的注释其提供什么级别的线程安全：</p><ul><li>Immutable–类都是常量，不需要额外的同步操作，比如String,Long BigInteger；</li><li>Unconditionally thread-safe–这种类的实例都是不可变的，但是其内部使用的同步来确保不需要额外的同步操作，比如AtomicLong；</li><li>Conditionally thread-safe–这种类需要外部的同步操作来保证并发安全，比如Collections.synchonized返回的集合包装类，他们的迭代操作都需要外部同步；</li><li>Not thread-safe–这种类的实例都是不可变的，想要并发的使用必须同步每一个操作，比如ArrayList和HashMap；</li><li>Thread-hostile–就算被外部同步操作包裹这种类也是不安全的；<br>客户端可以通过长时间持有公共锁对象发起拒绝服务攻击（denial-of-service），这种情况就需要一个私有的对象锁：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Object</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">foo</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">synchronized</span>(lock) &#123;<br>        …<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面的锁对象声明为final，所有的锁属性（对象）都应该声明为final；私有锁对象只适用于Uncondionally thread-safe类，而无法使用在Condionally thread-safe类，因为必须在文档中声明客户端在执行操作时应该获取什么锁，而这个锁是私有的，无法获取。</p><p>总的来说每个类都应该在文档中仔细说明其线程安全相关信息；Condionally thread-safe需要说明哪些操作需要外部同步，需要获取哪些锁；Uncondionally thread-safe则需要声明一个私有的对象锁来在类内部实现同步。</p><h2 id="Item-83-：Use-lazy-initialization-judiciously"><a href="#Item-83-：Use-lazy-initialization-judiciously" class="headerlink" title="Item 83 ：Use lazy initialization judiciously"></a>Item 83 ：Use lazy initialization judiciously</h2><p><strong>有选择的使用懒加载</strong></p><p>只有在需要的时候使用懒加载，大部分的场景都推荐使用正常的初始化方式，同时使用了懒加载应该作性能对比（和不使用懒加载）在多线程的场景下使用懒加载需要进行同步，否则会出现严重的问题。</p><p>对于静态属性，使用容器类来进行懒加载：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Lazy initialization holder class idiom for static fields</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FieldHolder</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">FieldType</span> <span class="hljs-variable">field</span> <span class="hljs-operator">=</span> computeFieldValue();<br>&#125;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> FieldType <span class="hljs-title function_">getField</span><span class="hljs-params">()</span> &#123; <br>    <span class="hljs-keyword">return</span> FieldHolder.field; <br>&#125;<br></code></pre></td></tr></table></figure><p>普通属性懒加载时使用double-check来提高性能，避免了在初始化后锁所带来的性能消耗：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> FieldType field;<br><span class="hljs-keyword">private</span> FieldType <span class="hljs-title function_">getField</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">FieldType</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> field;<br>    <span class="hljs-keyword">if</span> (result == <span class="hljs-literal">null</span>) &#123; <span class="hljs-comment">// First check (no locking)</span><br>        <span class="hljs-keyword">synchronized</span>(<span class="hljs-built_in">this</span>) &#123;<br>        <span class="hljs-keyword">if</span> (field == <span class="hljs-literal">null</span>) <span class="hljs-comment">// Second check (with locking)</span><br>            field = result = computeFieldValue();<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><p>field声明为volatile非常重要。<br>single-check ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Single-check idiom - can cause repeated initialization!</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> FieldType field;<br><span class="hljs-keyword">private</span> FieldType <span class="hljs-title function_">getField</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">FieldType</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> field;<br>    <span class="hljs-keyword">if</span> (result == <span class="hljs-literal">null</span>)<br>        field = result = computeFieldValue();<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果重复的初始化可以接受，可以使用上面的方式初始化，同样field会被声明为volatile。总的来说如果需要使用懒加载来提高性能，静态属性使用容器类来进行懒加载，普通属性使用double-check，如果不介意重复初始化属性则可以使用single-checke。</p><h2 id="Item-84-Don’t-depend-on-the-thread-scheduler"><a href="#Item-84-Don’t-depend-on-the-thread-scheduler" class="headerlink" title="Item 84 : Don’t depend on the thread scheduler"></a>Item 84 : Don’t depend on the thread scheduler</h2><p><strong>不要依赖线程调度器</strong></p><p>在多线程的情况下线程调度器决定着线程的启动和运行时间，任何依赖线程调度器来获取正确结果或者提升性能的程序基本都不可移植。应该尽量保证运行的线程不要超过处理器核心数量，控制运行线程数量可以让每个线程处理有用的工作并且待处理更多，线程在不处理有用工作的时候不应该运行。</p><p>同时线程不应该处理忙等待，反复检查共享资源是否可用。忙等待会增加处理器负载，减少其他线程可完成有用工作的数量。</p><p>当遇到程序由于其他线程占用导致很少运行时，不要使用 Thread.yield 来’修复’程序，最好是减少并发线程数量。尽管Java有线程优先级可以进行设置，但是最好不要通过降低线程优先级来解决严重的线程存活问题。</p><blockquote class="copyright"><p>本站所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">BY-NC-SA 4.0</a> 许可协议。转载请注明出处！</p></blockquote></main><nav class="pagination"><span class="prev"><a href="/posts/539">EFFECTIVE JAVA 3RD EDITION — 第十二章 序列化 </a></span><span class="next"><a href="/posts/511">EFFECTIVE JAVA 3RD EDITION — 第十章 异常</a></span></nav><script src="/js/main.js"></script><footer><p class="socials"><a href="https://github.com/lostars" target="_blank"><svg class="fontawesome-icon"><use href="/icons/fontawesome.svg#github"></use></svg> </a><a href="https://open.spotify.com/user/boyizmen" target="_blank"><svg class="fontawesome-icon"><use href="/icons/fontawesome.svg#spotify"></use></svg> </a><a href="https://space.bilibili.com/20516992" target="_blank"><svg class="fontawesome-icon"><use href="/icons/fontawesome.svg#bilibili"></use></svg> </a><input type="hidden" id="emailUser" value="bW9tbw=="> <input type="hidden" id="emailDomain" value="bWluZWkubWU="> <a id="emailLink" href="#" target="_blank"><svg class="fontawesome-icon"><use href="/icons/fontawesome.svg#email"></use></svg></a></p><p>Build with ❤ I abandon here my love</p><p>Copyright &copy; 2025 boyizmen</p></footer></body></html>